import{o as e,c as r,a as n}from"./app.e2261b09.js";const a='{"title":"Основы команд Linux - 7 команд для управления процессами","description":"","frontmatter":{"title":"Основы команд Linux - 7 команд для управления процессами","date":"2020-12-07T11:22:05.000Z","cover_index":"http://picsum.photos/450/450?random=42","tags":["Linux","CLI"],"categories":["Innovate","CLI"]},"headers":[{"level":2,"title":"Дополнительные ресурсы Linux","slug":"допоnнитеnьные-ресурсы-linux"},{"level":2,"title":"Что нужно для начала","slug":"что-нужно-дnя-начаnа"},{"level":2,"title":"Подведение итогов","slug":"подведение-итогов"}],"relativePath":"blog/linux-command-basics-7-commands-process-management.md","lastUpdated":1628440207824}',s={},t=n('<p>Если вы новичок в Linux и вам нужна помощь в управлении процессами, эти базовые команды для вас.</p><p>Предположим, вы впервые изучаете командную строку Linux или входите в систему администрирования Linux. В этом случае очень важно понимать, как обходить терминал и выполнять основные задачи. Чтобы помочь вам понять эти концепции, ознакомьтесь с двумя моими предыдущими статьями:</p><ul><li><a href="https://www.redhat.com/sysadmin/10-commands-terminal" target="_blank" rel="noopener noreferrer">10 команд для начала работы с терминалом</a></li><li><a href="https://www.redhat.com/sysadmin/10-more-commands-terminal" target="_blank" rel="noopener noreferrer">Еще 10 команд для управления файлами</a></li></ul><p>Однако, если вы чувствуете себя комфортно с этими концепциями, в этой статье мы немного расширим ваши знания о Linux. Мы рассмотрим процессы и способы управления ими.</p><p>Итак, что же такое <em>процесс</em> ?</p><h2 id="допоnнитеnьные-ресурсы-linux"><a class="header-anchor" href="#допоnнитеnьные-ресурсы-linux" aria-hidden="true">#</a> Дополнительные ресурсы Linux</h2><ul><li><a href="https://developers.redhat.com/cheat-sheets/advanced-linux-commands/?intcmp=701f20000012ngPAAQ" target="_blank" rel="noopener noreferrer">Шпаргалка по расширенным командам Linux для разработчиков</a></li><li><a href="https://access.redhat.com/products/red-hat-insights/?intcmp=701f20000012ngPAAQ" target="_blank" rel="noopener noreferrer">Начните работу с Red Hat Insights</a></li><li><a href="https://developers.redhat.com/cheat-sheets/linux-commands-cheat-sheet/?intcmp=701f20000012ngPAAQ" target="_blank" rel="noopener noreferrer">Загрузить сейчас: шпаргалка по основным командам Linux</a></li><li><a href="https://rhtapps.redhat.com/assessment/?intcmp=701f20000012ngPAAQ" target="_blank" rel="noopener noreferrer">Оценка навыков системного администрирования Linux</a></li></ul><p>В Linux процесс - это любой активный (запущенный) экземпляр программы. Но что такое <em>программа</em> ? Что ж, технически программа - это любой исполняемый файл, хранящийся на вашем компьютере. Каждый раз, когда вы запускаете программу, вы создаете процесс. На базовом уровне этим довольно легко управлять, и именно это мы и рассмотрим сегодня.</p><h2 id="что-нужно-дnя-начаnа"><a class="header-anchor" href="#что-нужно-дnя-начаnа" aria-hidden="true">#</a> Что нужно для начала</h2><p>Я рекомендую вам следить за своей любимой виртуальной машиной. Таким образом, вы можете попытаться и потерпеть неудачу без каких-либо последствий (что, безусловно, лучший способ освоиться в терминале).</p><p>Для этой демонстрации я собираюсь запустить процесс <a href="https://man7.org/linux/man-pages/man3/sleep.3.html" target="_blank" rel="noopener noreferrer">сна</a> на 500 секунд. Такой подход позволяет вам увидеть процесс, не внося существенных изменений в мою систему.</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ sleep 500\n    ^Z\n    [1]+  Stopped                 sleep 500\n</code></pre></div><p>Затем я остановил процесс с помощью <strong>Ctrl + Z,</strong> чтобы мы могли использовать наш терминал.</p><h4 id="_1-перечисnите-процессы"><a class="header-anchor" href="#_1-перечисnите-процессы" aria-hidden="true">#</a> 1. Перечислите процессы</h4><p>Чтобы отобразить текущие активные процессы, используйте psкоманду:</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ ps\n        PID TTY          TIME CMD\n       2648 pts/0    00:00:00 bash\n       3293 pts/0    00:00:00 sleep\n       3300 pts/0    00:00:00 ps\n</code></pre></div><p>Здесь вы получите небольшую информацию об активных процессах в вашей системе. Вам нужно обратить внимание на <strong>PID</strong> (уникальный идентификатор процесса), <strong>TIME</strong> (время, в течение которого процесс был запущен) и <strong>CMD</strong> (команда, выполняемая для запуска процесса).</p><h4 id="_2-подробный-список-процессы"><a class="header-anchor" href="#_2-подробный-список-процессы" aria-hidden="true">#</a> 2. Подробный список (процессы)</h4><p>Чтобы увидеть невероятно подробный список процессов, вы можете использовать ps aux команду.</p><ul><li>а - все пользователи</li><li>u - показывает пользователя / владельца</li><li>x - отображает процессы, которые не выполняются в терминале (что делает вывод довольно длинным)</li></ul><p>Вы можете увидеть команду здесь (вывод изменен по длине):</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ ps aux\n    USER         PID %CPU %MEM   VSZ    RSS   TTY  STAT  START    TIME   COMMAND\n    tcarrig+    3293  0.0  0.0 215292   520 pts/0    T    13:41   0:00 sleep 500\n    root        3380  0.0  0.0      0     0 ?        I    13:45   0:00 [kworker/1:1-mm_percpu_wq]\n    root        3381  0.0  0.0      0     0 ?        I    13:45   0:00 [kworker/1:3]\n    root        3398  0.0  0.0      0     0 ?        I    13:46   0:00 [kworker/3:2-ata_sff]\n    root        3481  0.0  0.0      0     0 ?        I    13:50   0:00 [kworker/u8:2-flush-253:0]\n    root        3482  0.0  0.0      0     0 ?        I    13:50   0:00 [kworker/0:1-events]\n    root        3483  0.0  0.0      0     0 ?        I    13:50   0:00 [kworker/0:2]\n    root        3508  0.0  0.0      0     0 ?        I    13:51   0:00 [kworker/3:0-ata_sff]\n    root        3511  0.0  0.0  18892  7732 ?        S    13:52   0:00 systemd-userwork\n    root        3512  0.0  0.0  18892  7656 ?        S    13:52   0:00 systemd-userwork\n    root        3513  0.0  0.0  18892  7656 ?        S    13:52   0:00 systemd-userwork\n    root        3566  0.4  0.0 432792  8024 ?        Ssl  13:54   0:00 /usr/libexec/fprintd\n    tcarrig+    3598  0.0  0.0 228208  3948 pts/0    R+   13:54   0:00 ps aux\n</code></pre></div><h4 id="_3-убить-по-pid"><a class="header-anchor" href="#_3-убить-по-pid" aria-hidden="true">#</a> 3. Убить по PID</h4><p>Неизбежно процесс зависнет, и вам это понадобится kill. Чем больше времени вы проводите в интерфейсе командной строки, тем больше вероятность, что вам понадобится killкоманда. Самый точный способ идентифицировать процесс - это идентификатор процесса (PID).</p><p>Используйте следующий синтаксис:</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ kill PID\n</code></pre></div><p>Эта команда отправляет сигнал <strong>SIGTERM</strong> . Однако, если вы имеете дело с зависшим процессом, добавьте эту -9опцию.</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ ps\n        PID TTY          TIME CMD\n       2648 pts/0    00:00:00 bash\n       3293 pts/0    00:00:00 sleep\n       4684 pts/0    00:00:00 sleep\n      40527 pts/0    00:00:00 sleep\n      40540 pts/0    00:00:00 ps\n    [tcarrigan@client ~]$ sudo kill -9 3293\n    [sudo] password for tcarrigan: \n    [1]   Killed                  sleep 500\n</code></pre></div><h4 id="_4-убить-по-имени-кnючевому-сnову"><a class="header-anchor" href="#_4-убить-по-имени-кnючевому-сnову" aria-hidden="true">#</a> 4. Убить по имени / ключевому слову</h4><p>Используйте killallкоманду, чтобы убить процесс по имени. Эта команда уничтожит все процессы с указанным вами ключевым словом / именем.</p><p>Синтаксис:</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ killall sleep\n</code></pre></div><p>Это убьет все sleepактивные процессы в системе (этот -9параметр также работает). Вот пример:</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ ps\n        PID TTY          TIME CMD\n       2648 pts/0    00:00:00 bash\n       4684 pts/0    00:00:00 sleep\n      40527 pts/0    00:00:00 sleep\n      40540 pts/0    00:00:00 ps\n    [tcarrigan@client ~]$ killall -9 sleep \n    [2]-   Killed                  sleep 500\n    [3]+   Killed                  sleep 500\n</code></pre></div><p>Следующие две команды идут рука об руку. Они позволяют вам перемещать / управлять фоновыми командами. Я дам общий взгляд на синтаксис ниже; однако для более подробного изучения этих команд см. мою <a href="https://www.redhat.com/sysadmin/jobs-bg-fg" target="_blank" rel="noopener noreferrer">предыдущую статью</a> на эту тему.</p><h4 id="_5-составьте-список-фоновых-заданий-и-возобновите-фоновые-задания"><a class="header-anchor" href="#_5-составьте-список-фоновых-заданий-и-возобновите-фоновые-задания" aria-hidden="true">#</a> 5. Составьте список фоновых заданий и возобновите фоновые задания</h4><p>Для составления списка фоновых заданий и управления ими мы будем использовать bgкоманду. Я запустил новый sleep 500 процесс, а затем остановил его, отправив в фоновый режим. Таким образом, мы видим его в списке при запуске bgниже:</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ bg\n    [1]+ sleep 500 &amp;\n</code></pre></div><h4 id="_6-выведите-на-передний-пnан-самую-посnеднюю-работу"><a class="header-anchor" href="#_6-выведите-на-передний-пnан-самую-посnеднюю-работу" aria-hidden="true">#</a> 6. Выведите на передний план самую последнюю работу.</h4><p>Для этого воспользуемся fg командой. Это выводит на передний план последнее запущенное задание / процесс. Следующий пример является продолжением указанной выше команды. sleep 500 Процесс , который находится в фоновом режиме в настоящее время работает в фоновом режиме. Вынесем это на свет ...</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ fg\n    sleep 500\n</code></pre></div><p>Эта команда подводит нас к нашей последней команде в этом списке.</p><h4 id="_7-выдвигайте-конкретную-работу-на-передний-пnан"><a class="header-anchor" href="#_7-выдвигайте-конкретную-работу-на-передний-пnан" aria-hidden="true">#</a> 7. Выдвигайте конкретную работу на передний план.</h4><p>Используйте fg команду еще раз, но выберите конкретное задание, которое нужно вывести на передний план (вместо самого последнего). Для этого мы просто добавим в команду имя задания / процесса.</p><div class="language-"><pre><code>    [tcarrigan@client ~]$ fg XXXample\n</code></pre></div><p>Это выводит задание <strong>XXXample</strong> на передний план.</p><p><em><strong>[Хотите проверить свои навыки системного администратора? <a href="https://www.redhat.com/rhtapps/assessment/?intcmp=701f20000012ngPAAQ" target="_blank" rel="noopener noreferrer">Пройдите оценку навыков сегодня.</a>]</strong></em></p><h2 id="подведение-итогов"><a class="header-anchor" href="#подведение-итогов" aria-hidden="true">#</a> Подведение итогов</h2><p>В сегодняшней статье «Основы команд Linux» мы рассмотрели процессы и способы управления ими. Теперь вы можете выполнять общие задачи управления процессами - все, от перечисления и уничтожения до перехода между фоном и передним планом. Если есть другие общие области администрирования Linux, для которых вы хотели бы видеть специальный список команд, напишите команде по адресу [enable-sysadmin@redhat.com][13] , и я сделаю все возможное, чтобы [конкретизировать][13] это для вас.</p>',49);s.render=function(n,a,s,l,p,i){return e(),r("div",null,[t])};export{a as __pageData,s as default};
