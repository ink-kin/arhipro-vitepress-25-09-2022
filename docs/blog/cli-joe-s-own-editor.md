---
title: JOE - Joe's Own Editor -- ДЖО - собственный CLI редактор Джо
date: 2002-02-22 22:22:22
tags:
- joe
- cli
categories:
- books
---

# [JOE - Joe's Own Editor -- ДЖО - собственный редактор Джо][0]

## [Синтаксис][1]

**joe [global-options] [[local-options] filename] ...**  
**jstar [global-options] [[local-options] filename] ...**  
**jmacs [global-options] [[local-options] имя файла] .. .**  
**rjoe [глобальные опции] [[местные-опции] имя файла] ...**  
**jpico [глобальные опции] [[местные-опции] имя файла] ...**

## [Описание][2]

JOE - мощный редактор экрана консоли. Он имеет "безрежимный" пользовательский интерфейс, который похож на многие удобные редакторы для ПК. Пользователи языков WordStar от Micro-Pro или «Turbo» от Borland будут чувствовать себя как дома. JOE - это полнофункциональный экранный редактор UNIX, который имеет множество функций для редактирования программ и текста.

JOE также эмулирует несколько других редакторов. JSTAR - близкая имитация WordStar со многими расширениями "JOE". JPICO - близкая имитация редактора PICO почтовой системы Pine, но с множеством расширений и улучшений. JMACS - это имитация GNU-EMACS. RJOE - это ограниченная версия JOE, которая позволяет редактировать только файлы, указанные в командной строке.

Хотя на самом деле JOE - это пять разных редакторов, для него по-прежнему требуется только один исполняемый файл, но с пятью разными именами. Имя редактора с добавленным «rc» дает имя файла инициализации JOE, который определяет личность редактора.

JOE - бесплатное программное обеспечение; вы можете распространять и / или изменять его в соответствии с условиями Стандартной общественной лицензии GNU, опубликованной Free Software Foundation. JOE доступен в Интернете по [адресу http://www.sourceforge.net/projects/joe-editor][3] .

## [Применение][4]

Чтобы запустить редактор, введите **joe,** а затем ноль или несколько имен файлов, которые вы хотите отредактировать. Каждому имени файла может предшествовать установка локального параметра (см. Следующую таблицу локальных параметров). Другие глобальные параметры, которые применяются ко всему редактору в целом, также могут быть помещены в командную строку (см. Следующую таблицу глобальных параметров). Если вы редактируете новый файл, вы можете указать имя нового файла при вызове редактора или в редакторе при сохранении нового файла. Предоставляется модифицированный синтаксис для имен файлов, позволяющий редактировать вывод программы, стандартный ввод / вывод или разделы файлов или устройств. См. Подробности в разделе « [Имена файлов»][5] ниже.

Находясь в редакторе, вы можете вводить текст и использовать специальные последовательности управляющих символов для выполнения других задач редактирования. Чтобы узнать, что такое последовательности управляющих символов, прочтите оставшуюся часть этой справочной страницы или введите **^ KH** для получения справки в редакторе.

А теперь немного малоизвестных компьютерных знаний:

В **^** означает , что вы удерживаете **Control** клавиши при нажатии на следующую клавишу ( Таким же образом **сдвиг** ключ работает для заглавных букв). Ряд последовательностей управляющих клавиш дублируется на других клавишах, поэтому вам не нужно нажимать управляющую клавишу: **Esc** будет работать вместо **^ [** , **Del** будет работать вместо **^?**, **Backspace** будет работать вместо **^ H** , **Tab** будет работать вместо **^ I** , **Return** или **Enter** будет работать вместо **^ M,** а **перевод строки** будет работать вместо**^ Дж** . На некоторых клавиатурах могут возникнуть проблемы с некоторыми клавишами управления. **^ _** , **^^** и **^ @** обычно можно ввести без нажатия клавиши Shift (например, попробуйте **^ -** , **^ 6** и **^ 2** ). Другие клавиатуры могут переназначить их другим клавишам. Попробуйте: **^.**, **^** и **^ /** . **^** Обычно можно использовать **пробел** вместо **^ @** . **^ \** и **^]** интерпретируются многими коммуникационными программами, включая telnet и kermit. Обычно вы просто дважды нажимаете кнопку, чтобы она прошла через коммуникационную программу.

На некоторых клавиатурах удерживание клавиши **Alt** при нажатии другой клавиши аналогично нажатию клавиши **Esc** перед нажатием другой клавиши.

После того, как вы наберете **^ KH** , в верхней части экрана появится первое окно справки. Вы можете продолжать вводить и редактировать текст, пока открыто окно справки. Чтобы пролистать другие темы, нажмите **Esc** и **Esc.**(то есть **Esc** и **Esc.** ). Используйте **^ KH,** чтобы закрыть окно справки.

Вы можете настроить раскладку клавиатуры, экраны справки и ряд параметров поведения по умолчанию, скопировав файл инициализации JOE (обычно **/ etc / joe / joerc** ) в **.joerc** в вашем домашнем каталоге, а затем изменив его. См. Раздел [joerc][6] ниже.

Чтобы использовать JOE в качестве редактора по умолчанию для электронной почты и новостей, вам необходимо установить **переменные** среды **EDITOR** и **VISUAL** в файле инициализации оболочки ( **.cshrc** или **.profile** ) так, чтобы они ссылались на JOE (JOE обычно находится как **/ usr / bin / Джо** ).

Есть ряд других непонятных параметров вызова, которые, возможно, придется установить, особенно если экран вашего терминала не обновляется так, как вы думаете. См. Раздел « [Переменные среды»][7] ниже.

## [Параметры командной строки][8]

Эти параметры также можно указать в файле joerc. Локальные параметры могут быть установлены в зависимости от расширения имени файла. В программах (с расширением .c, .h или .p) обычно включен автоотступ. Wordwrap включен для других файлов, но для RC-файлов он отключен.

Параметр включен, если он задан следующим образом:

    -wordwrap
    

Параметр отключен, если он задан следующим образом:

    --wordwrap
    

Некоторые варианты требуют аргументов. Аргументы приводятся так:

    -lmargin 5
    

В командной строке можно указать следующие глобальные параметры:

* asis   
Символы с кодами выше 127 будут отправлены на терминал как есть, а не как инверсии соответствующего символа ниже 128. Если это не сработает, проверьте свой терминальный сервер. Этот параметр не действует, если используется кодировка UTF-8.
* accept_256color   
Предположим, что ANSI-подобный эмулятор терминала поддерживает 256 цветов, даже если запись termcap говорит, что это не так.
* accept_color   
Предположим, что ANSI-подобный эмулятор терминала поддерживает цвет, даже если запись в termcap говорит, что это не так.
* autoswap   
Автоматически заменять **^ KB** на **^ KK,** если необходимо отметить допустимый блок во время команд копирования / перемещения блока.
* backpath path   
Устанавливает путь к каталогу, в котором должны храниться все файлы резервных копий. Если этот параметр не установлен (по умолчанию), файлы резервных копий хранятся в каталоге, содержащем файл.
* baud nnn   
Установить скорость передачи данных для оптимизации экрана терминала (отменяет значение, сообщаемое stty). JOE вставляет задержки для скоростей передачи ниже 19200 бод, что позволяет обойти буферизацию tty, так что typeahead прерывает вывод на экран. Команды прокрутки не будут использоваться для 38400 бод и выше. Это полезно для X-terms и других консольных терминалов, которые на самом деле не проходят через последовательную линию.
* beep   
Включить звуковые сигналы, когда команды редактирования возвращают ошибки, например, когда курсор выходит за крайние пределы.
* break_links   
Когда включено, JOE сначала удаляет файл перед его записью, чтобы разорвать жесткие и символические ссылки.
* break_hardlinks   
Если этот параметр включен и файл не является символической ссылкой , JOE сначала удаляет файл перед его записью, чтобы разорвать жесткие ссылки.
* brpaste   
При запуске JOE отправьте команду эмулятору терминала, которая включает «режим вставки в скобках» (но только если на терминале есть набор команд ANSI). В этом режиме текст, вставленный в окно, заключен в квадратные скобки с ESC [2 0 0 ~ и ESC [2 0 1 ~.
* цветовая **схема**  
Устанавливает цветовую схему.
* columns nnn   
Устанавливает количество столбцов в эмуляторе терминала (в случае неправильного ввода termcap). Это полезно только в старых системах, у которых нет ioctl "получить размер окна".
* csmode   
Включить режим непрерывного поиска: Последовательные **^ KF** повторяют текущий поиск вместо запроса нового.
* dopadding   
Разрешить JOE отправлять на терминал заполнение NUL (для очень старых терминалов).
* exask   
Если установлено, **^ KX** запрашивает новое имя перед сохранением файла.
* floatmouse   
Если установлено, щелчки мыши могут помещать курсор за концы строк.
* guess_crlf   
Если установлено, JOE пытается угадать формат файла MS-DOS или UNIX.
* guess_indent   
Если установлено, JOE пытается угадать символ отступа и шаг отступа на основе содержимого файла. Алгоритм состоит в том, чтобы найти наибольший общий множитель из трех наиболее распространенных углублений, обнаруженных в файле.
* guess_non_utf8   
Если установлено, включить угадывание файлов, отличных от UTF-8, в локали UTF-8.
* guess_utf8   
Если установлено, разрешить угадывание файлов UTF-8 в локали, отличной от UTF-8.
* guess_utf16   
Если установлено, разрешить угадывание файлов UTF-16. Если обнаружен файл UTF-16BE или UTF-16LE, он преобразуется в UTF-8 во время загрузки и преобразуется обратно в UTF-16 во время сохранения.
* helpon   
Когда установлено, начните с включенной интерактивной справкой .
* help_is_utf8   
При установке предполагается , что текст справки в файле joerc имеет кодировку UTF-8.
* hiline   
Если установлено, текущая строка выделяется. Текущая цветовая схема должна поддерживать это.
* При настройке icase   
Search по умолчанию учитывается регистр.
* joe_state   
Разрешить чтение и запись файла ~ / .joe_state
* joexterm   
Установите это, если xterm был настроен с параметром --paste64 для лучшей поддержки мыши.
* keepup   
Номер столбца в строке состояния постоянно обновляется, если он установлен, в противном случае он обновляется только раз в секунду.
* language **language**  
Устанавливает язык для aspell.
* lightoff   
Автоматически отключает выделение **^ KB****^ KK** после операции блока.
* lines nnn   
Устанавливает количество строк в эмуляторе терминала (в случае неправильного ввода termcap). Это полезно только в старых системах, у которых нет ioctl "получить размер окна".
* маркировка   
Включить режим маркировки: выделяется между **^ KB** и курсором.
* menu_above   
Поместите меню над подсказкой, а не под ней.
* menu_explorer   
Оставаться в меню, когда каталог выбран (в противном случае каталог добавляется к пути, и курсор возвращается к приглашению).
* menu_jump   
Переход в меню выбора файла при нажатии **Tab****Tab** .
* mid   
Если этот параметр установлен и курсор перемещается за пределы окна, окно будет прокручиваться так, чтобы курсор оказался в центре. Эта опция принудительно устанавливается на медленных терминалах, у которых нет команд прокрутки.
* left nn   
Устанавливает количество столбцов, на которые экран прокручивается влево, когда курсор перемещается за левый край или когда выдается команда сканирования. Если nn отрицательное, то это часть экрана для прокрутки. Например, -2 означает прокрутку на 1/2 экрана.
* right nn   
Устанавливает количество столбцов, на которые экран прокручивается вправо, когда курсор перемещается за правый край или когда выдается команда crawlr. Если nn отрицательное, то прокручивается часть экрана. Например, -3 означает прокрутку на 1/3 экрана.
* мышь   
Включить поддержку мыши xterm.
* nobackups   
Отключить резервные копии файлов.
* nocurdir   
Отключить префикс текущего каталога в приглашениях.
* noexmsg   
Отключить сообщение о выходе («Файл не изменен, поэтому обновление не требуется»)
* nolinefeeds   
Отключить отправку перевода строки, чтобы сохранить историю экрана в буфере обратной прокрутки эмулятора терминала (актуально только при включенном режиме notite).
* nolocks   
Отключение совместимых с EMACS блокировок файлов.
* nomodcheck   
Отключить периодическую проверку модификации файла.
* nonotice   
Этот параметр предотвращает отображение уведомления об авторских правах при запуске редактора.
* nosta   
Эта опция удаляет самую верхнюю строку статуса. Это удобно, когда вы хотите видеть только текст на экране или если вы используете vt52.
* notagsmenu   
Отключить меню выбора для поиска по тегам с несколькими результатами.
* notite   
Отключите последовательности ti и te termcap, которые обычно настраиваются для сохранения и восстановления содержимого экрана терминала при запуске и выходе JOE.
* pastehack   
Если ввод с клавиатуры выполняется одним блоком, предположите, что это вставка мыши, и отключите автоотступ и перенос слов.
* noxon   
Отключить управление потоком **^ S** и **^ Q** , возможно, позволяя использовать **^ S** и **^ Q** в качестве клавиш редактора.
* orphan   
Сиротские дополнительные файлы, указанные в командной строке вместо того, чтобы создавать для них окна (файлы загружаются, но для доступа к ним необходимо использовать команды switch-buffer).
* pg nnn   
Задайте количество строк, которые будут сохраняться во время Page Up и Page Down (используйте -1 для размера окна 1/2).
* regex   
По умолчанию использовать стандартный синтаксис регулярных выражений вместо синтаксиса JOE (где специальные символы имеют свое значение, только если им предшествует обратная косая черта).
* восстановить   
Установите для восстановления позиций курсора до последних позиций ранее отредактированных файлов.
* rtbutton   
Поменять местами левую и правую кнопки мыши.
* search_prompting   
Показывает предыдущую строку поиска в команде поиска (как в PICO).
* skiptop nnn   
Если установлено значение N, первые N строк экрана терминала не используются JOE и вместо этого остаются с исходным содержимым. Это полезно для программ, которые вызывают JOE, чтобы оставить сообщение для пользователя.
* square   
Включить режим прямоугольного блока.
* транспонировать   
Транспонировать строки со столбцами во всех меню.
* title   
Отображение контекста (заголовков) в строке состояния. Если этот параметр включен, отображается первая строка функции, в которой находится курсор, в строке состояния. Файл синтаксиса context.jsf определяет, какие строки являются строками заголовка.
* type   
Выберите тип файла, заменив автоматически определенный тип. Типы файлов определены в файле **ftyperc** .
* undo_keep nnn   
Устанавливает количество сохраняемых записей отмены (0 означает бесконечность).
* usetabs   
Установите, чтобы разрешить операции с прямоугольными блоками использовать вкладки.
* wrap   
Разрешить поиск с переносом в начало файла.

В командной строке можно указать следующие локальные параметры:

* + nnn   
Курсор начинается на указанной строке.
* autoindent   
Включить режим автоматического отступа. Когда вы нажимаете **Enter** на строке с отступом, отступ дублируется на новую строку.
* c_comment   
Разрешить **^ G** пропускать комментарии в стиле C / _..._ /
* cpara **characters**  
Устанавливает список символов, которые могут отступать от абзацев.
* cnotpara **characters**  
Устанавливает список символов, с которых начинаются строки, которые определенно не являются частью абзацев.
* cpp_comment   
Включить **^ G** пропуск комментариев в стиле C ++ // ...
* crlf   
JOE использует CR-LF как конец строки вместо просто LF. Это для редактирования файлов MS-DOS или VMS.
* encoding **encoding**  
Установить **кодировку** файла (например, utf-8 или 8859-1).
* flowed   
Установите для принудительного добавления дополнительного пробела после каждой строки абзаца, кроме последней.
* force   
Когда установлено, последняя строка добавляется к файлу, если ее нет при сохранении файла.
* французский   
Если задано, после точек в форматах абзаца вставляется только один пробел вместо двух.
* hex   
Включить режим шестнадцатеричного дампа.
* выделить   
Включить подсветку синтаксиса.
* highlighter_context   
Разрешить использование файла синтаксиса для определения комментариев и строк, которые следует пропускать при сопоставлении **^ G.**
* indentc nnn   
Устанавливает символ отступа для сдвига влево и вправо ( **^ K** и **^ K.** ). Используйте 32 для **пробела** , 9 для **табуляции** .
* indentfirst   
Когда установлено, клавиша умного дома сначала переходит к точке отступа, в противном случае сначала переходит к столбцу 1.
* istep nnn   
Задает шаг отступа.
* linums   
Включить отображение номера строки.
* lmargin   
Установить левое поле.
* lmsg   
Определить сообщение в строке состояния слева.
* overwrite   
Включить режим замены. При вводе существующие символы заменяются вместо вставки перед ними.
* picture   
Включить режим «картинка» - позволяет курсору проходить за концы строк.
* pound_comment   
**^ G** игнорирует # ... комментарии.
* очистить При необходимости   
исправить отступ перед перемещением или умным возвратом. Например, если для отступа используется сочетание табуляции и пробелов, а indentc - это пробел, то до операции сдвига отступ будет преобразован во все пробелы.
* rdonly   
Установить режим только для чтения.
* rmargin nnn   
Установить правое поле.
* rmsg **string**  
Определение сообщения в строке состояния справа.
* semi_comment   
**^ G** игнорирует; ... Комментарии.
* single_quoted   
**^ G** игнорирует '...'
* smartbacks   
Включить умную обратную клавишу и вкладку. Когда этот режим установлен, backspace и tab indent или undent в зависимости от значений параметров istep и indentc.
* Клавиша «   
Домой» smarthome сначала перемещает курсор в начало строки, а при повторном нажатии - на первый непустой символ.
* smsg **string**  
Определяет формат команды статуса, когда курсор находится на символе .
* пробелы   
Вставка пробелов при нажатии клавиши **Tab** .
* синтаксис **синтаксис**  
Установить синтаксис для выделения синтаксиса.
* tab nnn   
Установить ширину табуляции.
* text_delimiters **список разделителей слов**  
Дайте список разделителей слов, через которые **^ G** будет проходить.

Например, «begin = end: if = elif = else = endif» означает, что **^ G** будет переключаться между совпадающими if, elif, else и endif.

* vhdl_comment   
**^ G** игнорирует - ... комментарии
* wordwrap   
JOE переносит предыдущее слово, когда вы вводите текст за правым полем.
* zmsg **string**  
Определяет формат команды статуса, когда курсор находится в конце файла.
* xmsg **string**  
Определить стартовое сообщение (обычно уведомление об авторских правах).
* aborthint **строка**  
Укажите последовательность клавиш для отображения в запросах на прерывание (обычно ^ C).
* helphint **string**  
Укажите последовательность клавиш для отображения в запросах о помощи (обычно ^ KH).

### [Цвета и атрибуты][9]

Комбинируйте атрибуты и до одного цвета переднего плана и одного цвета фона, чтобы создать аргументы для параметров цвета, таких как text_color. Например: жирный + bg_green + синий

* Атрибуты: полужирный, инверсный, мигающий, тусклый, подчеркивание и курсив.
* Цвета переднего плана: белый, голубой, пурпурный, синий, желтый, зеленый, красный или черный.
* Цвета фона: bg_white, bg_cyan, bg_magenta, bg_blue, bg_yellow, bg_green, bg_red или bg_black

С эмулятором терминала с 16 или 256 цветами (экспорт TERM = xterm-16color) становятся доступны эти более яркие цвета, чем обычно:

> Обратите внимание, что вам нужен xterm, который был скомпилирован для поддержки 16 или 256 цветов, и соответствующая запись termcap / terminfo для него.

* Передний план: БЕЛЫЙ, ГОЛУБОЙ, ПУРПУРНЫЙ, СИНИЙ, ЖЕЛТЫЙ, ЗЕЛЕНЫЙ, КРАСНЫЙ или ЧЕРНЫЙ
* Фон: bg_WHITE, bg_CYAN, bg_MAGENTA, bg_BLUE, bg_YELLOW, bg_GREEN, bg_RED или bg_BLACK

С эмулятором терминала 256 цветов (экспорт TERM = xterm-256color) становятся доступными:

> Обратите внимание, что вам нужен xterm, который был скомпилирован для поддержки 256 цветов, и соответствующая запись termcap / terminfo для него.

* fg_RGB и bg_RGB, где R, G и B ранжируются от 0 до 5. Итак: fg_500 ярко-красный.
* fg_NN и bg_NN дают оттенки серого, где интенсивность NN находится в диапазоне от 0 до 23.

### [Строки определения строки состояния][10]

-lmsg определяет строку, выровненную по левому краю, а -rmsg определяет строку, выровненную по правому краю. Первый символ -rmsg - это символ заливки фона.

-smsg определяет команду статуса ( **пробел ^ K** ). -zmsg определяет его, когда курсор находится в конце файла. Последний символ smsg или zmsg - это символ заполнения.

В этих строках можно использовать следующие escape-последовательности:

    %t  12 hour time
    %u  24 hour time
    %T  O for overtype mode, I for insert mode
    %W  W if wordwrap is enabled
    %I  A if autoindent is enabled
    %X  Rectangle mode indicator
    %n  File name
    %m  '(Modified)' if file has been changed
    %*  '*' if file has been changed
    %R  Read-only indicator
    %r  Row (line) number
    %c  Column number
    %o  Byte offset into file
    %O  Byte offset into file in hex
    %a  Ascii value of character under cursor
    %A  Ascii value of character under cursor in hex
    %w  Width of character under cursor
    %p  Percent of file cursor is at
    %l  No. lines in file
    %k  Entered prefix keys
    %S  '*SHELL*' if there is a shell running in window
    %M  Macro recording message
    %y  Syntax
    %e  Encoding
    %x  Context (first non-indented line going backwards)
    %dd day
    %dm month
    %dY year
    %Ename%  value of environment variable
    %Tname%  value of option (ON or OFF for Boolean options)
    

Также могут быть даны эти управляющие последовательности форматирования:

    \i  Inverse
    \u  Underline
    \b  Bold
    \d  Dim
    \f  Blink
    \l  Italic

## [Базовое редактирование][11]

Когда вы вводите символы в редактор, они обычно вставляются в редактируемый файл (или добавляются к файлу, если курсор находится в конце файла). Это нормальный режим работы редактора. Если вы хотите заменить какой-либо существующий текст, вам необходимо удалить старый текст до или после того, как вы введете заменяющий текст. **Backspace** ключ может быть использован для удаления текста: переместить курсор вправо после текста , который вы хотите удалить и нажмите **Backspace** несколько раз.

Нажмите **клавишу Enter** или **Return,** чтобы вставить разрыв строки. Например, если курсор находится в середине строки и вы нажмете **Enter** , строка будет разделена на две строки, а курсор появится в начале второй строки. Нажмите **Backspace** в начале строки, чтобы устранить разрыв строки.

Используйте клавиши со стрелками для перемещения по файлу. Если на вашей клавиатуре нет клавиш со стрелками (или они не работают по какой-либо причине), используйте **^ F** для перемещения вперед (вправо), **^ B** для перемещения назад (влево), **^ P** для перехода к предыдущей строке ( вверх) и **^ N** для перехода к следующей строке (вниз). Клавиши со стрелками вправо и влево просто перемещают вперед или назад по одному символу по тексту: если вы находитесь в начале строки и нажимаете стрелку влево, вы окажетесь в конце предыдущей строки. Клавиши со стрелками вверх и вниз перемещаются вперед и назад на достаточное количество символов, так что курсор появляется в том же столбце, в котором он находился в исходной строке.

Если вы хотите сделать отступ для вводимого текста, вы можете использовать клавишу **Tab** . Это вставляет специальный управляющий символ, который заставляет символы, следующие за ним, начинаться с следующей позиции табуляции. Табуляция обычно происходит каждые 8 ​​столбцов, но это можно изменить с помощью команды **^ TD** . Программисты на PASCAL и C часто устанавливают позиции табуляции на каждые 4 столбца.

Если по какой - то причине ваш экран терминала испортится (например, если вы получаете почту уведомление от Биф), вы можете иметь редактор обновить экран, нажав **^ R** .

Есть много других клавиш для удаления текста и перемещения по файлу. Например, нажмите **^ D,** чтобы удалить символ, на котором находится курсор, вместо удаления назад, как **Backspace** . **^ D** также удалит разрыв строки, если курсор находится в конце строки. Введите **^ Y,** чтобы удалить всю строку, на которой находится курсор, или **^ J,** чтобы удалить только от курсора до конца строки.

Нажмите **^ A,** чтобы переместить курсор в начало строки, на которой он находится. Нажмите **^ E,** чтобы переместить курсор в конец строки. Нажмите **^ U** или **^ V** для прокрутки курсора вверх или вниз на 1/2 экрана.   
«Прокрутка» означает, что текст на экране перемещается, но курсор остается на том же месте относительно экрана. Нажмите **^ KU** или **^ KV,** чтобы переместить курсор в начало или конец файла. Посмотрите на экраны справки в редакторе, чтобы найти еще больше команд удаления и перемещения.

Если вы допустили ошибку, вы можете нажать **^ _,** чтобы «отменить» ее. На большинстве клавиатур вы нажимаете просто **^ -,** чтобы получить **^ _** , но на некоторых вам, возможно, придется одновременно удерживать **клавиши Shift** и **Control,** чтобы получить это. Если вы «отменили» слишком много, вы можете «повторить» изменения, нажав **^^** ( на большинстве клавиатур набирайте это с помощью всего **^ 6** ).

### [История положения курсора][12]

Если вы редактировали в одном месте в файле, а затем вам пришлось временно просмотреть или отредактировать другое место в файле, вы можете вернуться в исходное место, нажав **^ K -** . Эта команда фактически возвращает вас в последнее место, где вы внесли изменения в файл. Вы можете перемещаться по истории мест с помощью **^ K -** и **^ K =** точно так же, как вы можете перемещаться по истории изменений с помощью команд «отменить» и «повторить».

### [Сохранить и выйти][13]

Когда вы закончите редактировать файл, нажмите **^ KX,** чтобы выйти из редактора. Вам будет предложено ввести имя файла, если вы еще не назвали файл, который редактировали.

Когда вы редактируете файл, вы фактически редактируете только его копию. Поэтому, если вы решите, что вам не нужны изменения, которые вы внесли в файл во время определенного сеанса редактирования, вы можете нажать **^ C,** чтобы выйти из редактора без их сохранения.

Если вы редактируете файл и сохраняете изменения, в текущем каталоге создается резервная копия этого файла с добавлением к имени **~** , содержащего исходную версию файла.

### [Файловые операции][14]

Вы можете нажать **^ KD,** чтобы сохранить текущий файл (возможно, под другим именем, отличным от того, как файл был назван изначально). После сохранения файла вы можете нажать **^ KE,** чтобы отредактировать другой файл.

Если вы хотите сохранить только выбранный раздел файла, см. Раздел « [Блоки»][15] ниже.

Если вы хотите включить другой файл в редактируемый файл, используйте **^ K R,** чтобы вставить его.

### [Имена файлов][5]

Везде, где JOE ожидает, что вы введете имя файла, будь то в командной строке или в приглашениях в редакторе, вы также можете ввести:

* ! команда

Для чтения или записи данных в команду оболочки или из нее. Например, используйте **joe '! Ls',** чтобы получить копию списка каталогов для редактирования, или из редактора используйте **^ KD! Mail jhallen@world.std.com,** чтобы отправить мне редактируемый файл.

* >> имя файла

Используйте это, чтобы JOE добавил отредактированный текст в конец файла «filename».

* имя файла, НАЧАЛО, РАЗМЕР

Используйте это для доступа к фиксированному разделу файла или устройства. **СТАРТ** и **РАЗМЕР** могут быть введены в десятичном (например, 123) восьмеричном (например: 0777) или шестнадцатеричном (например: 0xFF) виде. Например, используйте **joe / dev / fd0,508,2** для редактирования байтов 508 и 509 первого дисковода гибких дисков в Linux.

* -

Используйте это для получения ввода со стандартного ввода или для записи вывода на стандартный вывод. Например, вы можете поместить JOE в конвейер команд: **quota -v | Джо | корень почты** , если вы хотите пожаловаться на вашу низкую квоту.

### [Использование JOE в сценарии оболочки][16]

JOE использовал / dev / tty для доступа к терминалу. Это вызвало проблему с убийцами простоя (они убили бы JOE, потому что к настоящему tty-устройству не было доступа в течение длительного времени), поэтому теперь JOE использует / dev / tty только в том случае, если вам нужно передать файл в JOE, как в :

    echo "hi" | joe
    

Если вы хотите использовать JOE в сценарии оболочки, который перенаправлен на stdin / stdout, но вам не нужно перенаправлять его, вам следует просто перенаправить stdin / stdout JOE на / dev / tty:

    joe filename  </dev/tty >/dev/tty
    

### [Перенос слов и форматирование][17]

Если вы вводите текст за правым краем экрана в языковом файле C или PASCAL, экран будет прокручиваться вправо, следуя за курсором. Если вы введете текст за правым краем экрана в обычном файле (тот, имя которого не заканчивается на .c, .h или .p), JOE автоматически перенесет последнее слово в следующую строку, чтобы вы не нужно нажать **Enter** . Это называется режимом переноса слов. Перенос слов можно включить или выключить с помощью команды **^ TW** . Файл инициализации JOE обычно настроен так, что этот режим автоматически включается для всех непрограммных файлов. См. Раздел ниже в файле [joerc,][6] чтобы изменить это и другие значения по умолчанию.

Помимо режима переноса текста, JOE не сохраняет автоматически форматированные абзацы, как некоторые текстовые процессоры. Вместо этого, если вам нужно отформатировать абзац, нажмите **^ KJ** . Эта команда «заполняет» абзац, в котором находится курсор, помещая в строку как можно больше слов. В данном случае абзац представляет собой блок текста, разделенный сверху и снизу пустой строкой.

Поля, которые JOE использует для форматирования абзацев и переноса слов, можно установить с помощью команд **^ TL** и **^ TR** . Если для левого поля установлено значение, отличное от 1, то, когда вы начнете печатать в начале строки, курсор немедленно переместится к левому полю.

Существует ряд параметров, которые управляют форматированием абзацев и оболочкой слов:

* Параметр **cpara** предоставляет список символов, которые могут выступать в качестве отступа в абзаце. Например, в цитируемом электронном письме вопрос обозначается **>** в начале строки, поэтому этот символ должен быть в списке cpara.
* Параметр **cnotpara** предоставляет список символов, которые, если они являются первым непробельным символом в строке, указывают на то, что строку не следует включать как часть абзаца для форматирования. Например, строки, начинающиеся с символа "." в нроффе не может быть строк абзаца.
* Режим Autoindent влияет на форматтер. Если автоотступ отключен, только первая строка будет иметь отступ. Если автоотступ включен, весь абзац будет с отступом.
* **французский** определяет, сколько пробелов будет вставлено после точки.
* Если включен **поток** , после каждой строки абзаца, кроме последней, вставляется пробел. Это указывает на то, что в некоторых программах строки принадлежат к одному абзацу.
* Когда **замена** символов включена, то слово обертка не будет вставлять строки.

### [Центрирование][18]

Если вы хотите центрировать линию внутри полей, используйте команду **^ KA** .

### [Программа проверки орфографии][19]

Нажмите **Esc N,** чтобы проверить написание слова, на котором находится курсор, с помощью программы aspell (или программы ispell, если вы изменили файл joerc). Нажмите **Esc L,** чтобы проверить выделенный блок или весь файл, если ни один блок не выделен.

JOE передает язык и кодировку символов в средство проверки орфографии. Чтобы изменить язык, нажмите **^ TV** . Например, для английского языка используйте en_US.

### [Режим перепечатки][20]

Иногда утомительно удалять старый текст до или после вставки нового текста. Это происходит, например, когда вы меняете таблицу и хотите сохранить позицию столбца с правой стороны таблицы.   
Когда это происходит, вы можете перевести редактор в режим замены с помощью **^ TT** .   
Когда редактор находится в этом режиме, символы, которые вы вводите, заменяют существующие символы, как это сделала бы идеализированная пишущая машинка. Кроме того, **Backspace** просто перемещается влево вместо удаления символа слева, если он не находится в конце или начале строки. Режим перепечатки не является естественным способом работы с текстом в электронном виде, поэтому вам следует как можно скорее вернуться в режим вставки, снова набрав **^ TT** .

Если вам нужно вставить, когда вы находитесь в режиме перепечатки, нажмите **^ @** . В текст вставляется один **пробел** .

### [Управляющие и мета-символы][21]

Каждый символ представлен числом. Например, число для "A" - 65, а число для "1" - 49. Все символы, которые вы обычно видите, имеют числа в диапазоне от 32 до 126 (это конкретное произвольное сопоставление символов и чисел называется Набор символов ASCII). Числа вне этого диапазона от 0 до 255 обычно не отображаются, но иногда имеют другое особое значение. Например, число 10 используется для переноса строки. Вы можете ввести эти специальные, не отображаемые **управляющие символы** , сначала нажав **^ Q,** а затем нажав символ в диапазоне **@ ABC ... XYZ [^] \ _,** чтобы получить числа от 0 до 31 и? чтобы получить 127. Например, если вы нажмете **^ QJ**, вы вставите символ разрыва строки или, нажав **^ QI** , вы вставите символ **табуляции** (что делает то же самое, что и клавиша **Tab** ). Полезным управляющим символом для ввода является 12 ( **^ QL** ), который заставляет большинство принтеров перемещаться в верхнюю часть страницы. Вы заметите, что JOE отображает этот символ как подчеркнутый L. Вы можете ввести символы выше 127, **метасимволы** , сначала нажав **^ \** . Это добавляет 128 к следующему (возможно, контрольному) введенному символу. JOE отображает символы выше 128 в инверсном видео. Некоторые иностранные языки, в которых букв больше, чем в английском, используют метасимволы для остальной части своего алфавита. Вы должны поместить редактор в **asis** режим, чтобы они не были переведены на терминал.

**Примечание.** JOE теперь обычно передает все 8 битов на терминал, если локаль не установлена ​​на C или POSIX. Если языковой стандарт - C или POSIX, то флаг **asis** определяет , отображаются ли **метасимволы** в инверсном видео или передаются непосредственно на терминал.

**Примечание.** В старой версии JOE для ввода управляющих символов нужно было использовать **Esc** .

## [Наборы символов и UTF-8][22]

JOE изначально обрабатывает два класса наборов символов: UTF-8 и с байтовым кодом (например, ISO-8859-1). Для этих наборов символов файл загружается в память как есть и точно сохраняется во время сохранения, даже если он содержит ошибки кодировки UTF-8.

Он пока не может изначально обрабатывать другие основные классы, такие как UTF-16 или GB2312. Существуют и другие ограничения: наборы символов должны использовать LF (0x0A) или CR-LF (0x0D - 0x0A) в качестве ограничителей строки, пробел должен быть 0x20, а табуляция должна быть 0x09. Как правило, файлы должны быть текстовыми файлами, совместимыми с UNIX или MS-DOS.

Это означает, что EBCDIC не будет работать должным образом (но вам все равно придется обрабатывать строки с фиксированной длиной записи), а наборы символов, которые используют линии с завершением CR (MAC), еще не будут работать.

JOE теперь поддерживает UTF-16 (как с прямым, так и с прямым порядком байтов). Он поддерживает UTF-16 путем преобразования в UTF-8 во время загрузки и обратного преобразования в UTF-16 во время сохранения.

Терминал и файл могут иметь разные кодировки. ДЖО будет переводить между ними. В настоящее время для работы перевода один из двух должен быть UTF-8.

Набор символов для терминала и набор символов по умолчанию, предполагаемый для файлов, определяется переменной среды 'LC_ALL' (и если она не установлена, также проверяются LC_CTYPE и LANG).

Например, если для LC_ALL установлено значение:

    de_DE
    

Тогда набор символов будет ISO-8859-1.

Если LC_ALL установлен на:

    de_DE.UTF-8
    

Набор символов будет UTF-8.

Нажмите **^ TE,** чтобы изменить кодировку файла. Нажмите **Tab****Tab** в этом приглашении, чтобы получить список доступных кодировок. Существует ряд встроенных наборов символов, а также вы можете установить наборы символов в каталогах ~ / .joe / charmaps и / usr / share / joe / charmaps.

Проверьте: / usr / share / i18n / charmaps, например, файлы наборов символов. Только байтовые наборы символов будут работать. Кроме того, файл не должен быть сжат с помощью gzip (все файлы charmap в / usr / share / i18n / charmaps на моем компьютере были сжаты). Парсер очень плохой, поэтому в основном файл должен выглядеть точно так же, как пример в / usr / share / joe / charmaps.

Вы можете нажать **^ K Пробел,** чтобы увидеть текущий набор символов.

Вы можете нажать **^ Q x,** чтобы ввести символ Unicode, если кодировка файла - UTF-8.

## [Подсказки][23]

Большинство запросов записывают историю ваших ответов. Вы можете нажимать стрелки вверх и вниз, чтобы просматривать эти истории.

Подсказки на самом деле представляют собой однострочные окна без строки состояния, поэтому вы можете использовать любую команду редактирования, которую вы обычно используете для текста в подсказках. История приглашений - это фактически просто другие строки того же «файла приглашений». Таким образом, вы можете выполнять поиск в обратном направлении по истории запросов с помощью обычной команды **^ K F,** если хотите.

Поскольку подсказки являются окнами, вы также можете отключить их с помощью **^ KP** и **^ KN** .

### [Меню завершения и выбора][24]

Вы можете нажать **Tab практически** в любом запросе, чтобы попросить JOE завершить вводимое вами слово. Если ДЖО пищит, то либо завершений нет, либо много. Как и в случае с оболочкой "bash", дважды нажмите **Tab,** чтобы открыть список всех возможностей. Этот список на самом деле является меню, но по умолчанию курсор не перескакивает в него, поскольку обычно проще просто ввести свой выбор. Однако вы можете перейти в окно меню с помощью **^ KP** (перейти к предыдущему окну) и использовать клавиши со стрелками и <Enter>, чтобы сделать свой выбор. Также в меню вы можете нажать первую букву любого элемента, чтобы курсор прыгнул прямо на него. **T ^** меню опция работает следующим образом.

Если меню слишком велико и не помещается в окне, вы можете нажать Page Up и Page Down, чтобы прокрутить его (даже если вы не перескочили в него).

**Автозаполнение вкладок** работает и в запросах поиска и замены. В этом случае JOE пытается завершить слово на основе содержимого буфера. Если вам нужно найти сам символ **табуляции** , вы можете ввести его с помощью **^ Q Tab** .

Кроме того, вы можете нажать **Esc, Enter** в текстовом окне, чтобы попросить JOE завершить вводимое вами слово. Как и в случае с запросом поиска, JOE пытается завершить слово на основе содержимого буфера. Если вы дважды нажмете **Esc, Enter,** появится меню возможностей .

## [Где я?][25]

Нажмите **^ K Пробел,** чтобы JOE сообщил номер строки, номер столбца и номер байта в последней строке экрана. Также отображается номер, связанный с символом, на котором находится курсор (его код ASCII). Вы можете всегда отображать номер строки и / или номер столбца в строке состояния, поместив соответствующие escape-последовательности в строки настройки строки состояния. Отредактируйте файл joerc для получения подробной информации.

## [Что, если я случайно нажму **^ K** ?][26]

Нажмите пробел. Это запускает безобидную команду (она показывает номер строки в строке состояния).

## [Временное отключение редактора][27]

Если вам нужно временно остановить редактор и вернуться в оболочку, нажмите **^ KZ** . Возможно, вы захотите сделать это, чтобы остановить все, что вы редактируете, и, например, ответить на сообщение электронной почты или прочитать эту страницу руководства. Вам нужно набрать **fg** или **выйти** (вам сообщат, когда вы нажмете **^ KZ** ), чтобы вернуться в редактор. 

## [Поиск текста][28]

Нажмите **^ KF,** чтобы редактор начал искать фрагмент текста ( **строку** ) в прямом или обратном направлении за вас. Вам будет предложено ввести текст для поиска. После того, как вы нажмете **Enter** , вам будет предложено ввести параметры.   
Вы можете просто нажать **Enter еще** раз, чтобы редактор немедленно начал поиск текста, или вы можете ввести один или несколько из следующих параметров:

* **б**

Искать назад, а не вперед.

* **я**

При поиске обрабатывайте прописные и строчные буквы как одно и то же. Обычно прописные и строчные буквы считаются разными.

* **nnn**

(где **nnn** - это число). Если вы вводите число, JOE ищет N-е вхождение текста. Это полезно для перехода к определенным местам в файлах, структурированных обычным образом.

* **р**

Заменить текст. Если вы введете параметр **r** , вам будет предложено ввести текст для замены. Каждый раз, когда редактор находит искомый текст, вам будет предложено заменить найденный искомый текст на заменяющий. Вы нажимаете: **y,** чтобы заменить текст, а затем найти следующее вхождение, **n,** чтобы не заменять этот текст, а затем найти следующее вхождение, **r,** чтобы заменить все оставшиеся вхождения искомого текста в оставшейся части файла без запроса для подтверждения (с учетом параметра **nnn** выше) или **^ C,** чтобы остановить поиск и замену.

Вы также можете нажать **B** или **Backspace,** чтобы вернуться к ранее найденному тексту (если он был заменен, замена отменяется).

* **а**

Поиск охватывает все загруженные буферы. Итак, чтобы заменить все экземпляры «foo» на «bar» во всех файлах .c в текущем каталоге:

    joe *.c
       ^K F
           foo <Enter>
           ra <Enter>
           bar <Enter>
    

* **е**

Поиск охватывает все файлы в списке ошибок grep или make. Вы можете использовать команду UNIX для создания списка файлов и поиска и замены в этом списке. Итак, чтобы заменить все экземпляры «foo» на «bar» во всех файлах .c, которые начинаются с f. Вы также можете использовать «ls» и «find» вместо grep для создания списка файлов.

    Esc G
      grep -n foo f*.c <Enter>
    ^K F
           foo <Enter>
       re <Enter>
       bar <Enter>
    

* **Икс**

JOE будет использовать стандартный синтаксис для регулярных выражений, если указана эта опция. В стандартном синтаксисе эти символы напрямую имеют свое особое значение, и их не нужно экранировать обратной косой чертой:., *, +,?, {,}, (,), |, ^, $ И [.

* **у**

JOE будет использовать синтаксис JOE для регулярных выражений вместо стандартного синтаксиса. Это отменяет параметр "-regex".

* **v**

JOE отправит отладочную информацию о регулярном выражении в журнал запуска. Журнал можно просмотреть с помощью команды showlog.

Вы можете нажать **^ L,** чтобы повторить предыдущий поиск.

Вы можете нажать **^ KH** в **запросе** параметров поиска и замены, чтобы открыть список всех параметров поиска и замены.

### [Регулярные выражения][29]

В качестве текста для поиска можно ввести ряд специальных последовательностей символов:

* **\ ***

Это обнаружит ноль или более элементов слева. Например, если вы укажете **AB \ * C** в качестве текста для поиска, JOE попытается найти A, за которым следует любое количество B, а затем C.

* **\ +**

Это находит один или несколько предметов слева. Например, если вы укажете **AB \ + C** в качестве текста для поиска, JOE попытается найти A, за которым следует одна или несколько B, а затем C.

* **\?**

Это означает, что элемент слева не является обязательным. Например, если вы введете **AB \? C** в качестве текста для поиска, JOE найдет AC или ABC.

* **\{мин Макс}**

Это означает, что JOE должен попытаться найти строку с определенным количеством вхождений элемента слева. Например, **AX \ {2,5} B** будет соответствовать этим строкам: AXXB, AXXXB, AXXXXB и AXXXXXB. Min можно не указывать, чтобы указать 0 вхождений. Макс (и запятую) можно опустить, чтобы указать любое количество вхождений.

* **\.**

Будет найден ровно один персонаж. Например, если вы укажете **A \ .B** в качестве текста для поиска, JOE найдет AXB, но не AB или AXXB.

* **\!**

Это работает вроде **.**, но соответствует сбалансированному выражению на языке Си. Например, если вы ищете **таНос (\! \ *)** , То JOE найдет все вызовы функций **таНоса** , даже если было **)** в круглых скобках.

* **\ |**

Будет найден элемент слева или элемент справа. Например, если вы укажете **A \ | B** в качестве текста для поиска, JOE попытается найти либо A, либо B.

* **\ (\)**

Используйте их, чтобы сгруппировать персонажей вместе. Например, если вы ищете **\ (foo \) \ +** , то JOE найдет такие строки, как «foo» и «foofoofoo».

* **\ ^ \ $**

Они соответствуют началу и концу строк. Например, если вы даете **\ ^ тест \ $** , то JOE с находят **тест** на отдельной строке.

* **\ <\>**

Они соответствуют началу и концу слов. Например, если вы дадите **\**, то JOE найдет слово «есть», но не найдет «есть» в «этом».

* **\ [...]**

Это соответствует любому одиночному символу, указанному в скобках. Например, если в качестве строки поиска **ввести \ [Tt] his** , то JOE найдет и **This,** и **this** . В скобках можно вводить диапазоны символов. Например, **\ [AZ]** находит любую заглавную букву. Если первым в скобках указан символ **^** , то JOE пытается найти любой символ, не указанный в скобках. Чтобы включить **-** само, включите его как последний или первый символ (возможно, после **^** ).

* **\\**

Соответствует одиночному \.

* **\ п**

Это находит специальный символ конца или разрыва строки.

В строке замены также может быть указан ряд специальных последовательностей символов:

* **\ &**

Он заменяется текстом, который соответствует строке поиска. Например, если поисковая строка была **\ <\ * \>** , которая соответствует словам, и вы указали **«\ &»** , то JOE будет заключать слова в кавычки.

* **\ 1 - \ 9**

Они заменяются текстом, который соответствует N-й группе; текст в N-м наборе \ (\).

* **\ l, \ u**

Преобразуйте следующий символ замещающего текста в нижний или верхний регистр.

* **\ L, \ U**

Преобразуйте весь следующий замещающий текст в нижний или верхний регистр. Преобразование останавливается, когда встречается \ E.

* **\\**

Используйте это, если вам нужно поставить **\** в заменяющую строку.

* **\ п**

Используйте это, если вам нужно поместить разрыв строки в заменяющую строку.

Несколько примеров:

Предположим, у вас есть список адресов, каждый в отдельной строке, который начинается с «Address:» и содержит каждый элемент, разделенный запятыми. Вот так:

Адрес: S. Holmes, 221b Baker St., Лондон, Англия

Если вы хотите изменить порядок списка, чтобы получить сначала страну, затем город, затем имя человека, а затем адрес, вы можете сделать это:

Введите **^ KF,** чтобы начать поиск, и введите:

**Адрес: \ (\. \ * \), \ (\. \ * \), \ (\. \ * \), \ (\. \ * \) \ $**

для соответствия "Address:", четырем элементам, разделенным запятыми, а затем концу строки. Когда вас спросят о вариантах, вы должны ввести **r,** чтобы заменить строку, а затем ввести:

**Адрес: \ 4, \ 3, \ 1, \ 2**

Чтобы перетасовать информацию так, как вы хотите. После нажатия клавиши возврата начнется поиск, и строка образца изменится на:

Адрес: Англия, Лондон, S. Holmes, 221b Baker St.

### [Последовательности выхода][30]

JOE понимает следующие escape-последовательности в строках поиска и замены:

* \ x {10ffff}

Это соответствует определенной кодовой точке Unicode, заданной в шестнадцатеричном формате.

* \ xFF

Это соответствует конкретному символу, указанному в шестнадцатеричном формате.

* \ 377

Это соответствует конкретному символу, указанному в восьмеричном формате.

* \ p {Ll}

Это соответствует любому символу в названной категории или блоке Unicode.

Имена блоков, такие как "Latin-1 Supplement" или "Arabic", можно найти здесь: 

[Блоки Unicode][31]

Названия категорий, такие как "Ll", можно найти здесь:

[Категории Юникода][32]

Обратите внимание, что одна буква соответствует всем названиям категорий, которые начинаются с этой буквы. Например, \ p {N} (любое число) включает \ p {Nd} (десятичную цифру), \ p {Nl} (буквенное число) и \ p {No} (другое число).

* \ d

Это соответствует любой цифре Unicode. Это то же самое, что и \ p {Nd}.

* \ D

Это соответствует чему угодно, кроме цифры Unicode. Это то же самое, что и \ [^ \ p {Nd}].

* \ w

Это соответствует любому символу слова. Это то же самое, что и \ [^ \ p {C} \ p {P} \ p {Z}].

* \ W

Это соответствует чему угодно, кроме символа слова. Это то же самое, что и \ [\ p {C} \ p {P} \ p {Z}].

* \ s

Соответствует любому пробелу. Это то же самое, что и \ [\ t \ r \ f \ n \ p {Z}].

* \ S

Это соответствует чему угодно, кроме символа пробела. Это то же самое, что и \ [^ \ t \ r \ f \ n \ p {Z}].

* \я

Это соответствует начальному символу идентификатора. Это то же самое, что и \ [\ p {L} \ p {Pc} \ p {Nl}].

* \Я

Это соответствует чему угодно, кроме начального символа идентификатора. Это то же самое, что и \ [^ \ p {L} \ p {Pc} \ p {Nl}].

* \ c

Это соответствует символу продолжения идентификатора. Это то же самое, что и \ [\ i \ p {Mn} \ p {Mc} \ p {Nd} \ x {200c} \ x {200d}].

* \ C

Это соответствует чему угодно, кроме символа продолжения идентификатора. Это то же самое, что и \ [^ \ i \ p {Mn} \ p {Mc} \ p {Nd} \ x {200c} \ x {200d}].

* \ t Вкладка
* \ n Новая строка
* \ r возврат каретки
* \ b Backspace
* \ a Предупреждение
* \ f Formfeed
* \ e Побег
* \\ обратная косая черта

## [Инкрементный поиск][33]

Используйте **Esc S,** чтобы начать инкрементный поиск вперед, или **Esc R,** чтобы начать инкрементный поиск назад. По мере ввода строки поиска курсор переместится к первому тексту, соответствующему введенному вами регулярному выражению.

**Еще раз** нажмите **Esc S** или **Esc R,** чтобы найти следующее вхождение текста или изменить направление поиска.

**^ S** , **^ \** и **^ L** имеет тот же эффект , как и **Esc S** . **^ R** имеет тот же эффект , как и **Esc R** . Эти ключи предназначены для поддержки JMACS.

Нажмите **Backspace,** чтобы отменить последнее действие инкрементного поиска. Последним действием может быть повторение предыдущего поиска или ввод нового символа.

Используйте **^ Q,** чтобы вставить управляющие символы в поисковый текст. Раньше для этого также можно было использовать `.

Нажмите любую другую клавишу, чтобы выйти из поиска приращения. 

## [Перейти к соответствующему разделителю][34]

Нажмите **^ G,** чтобы переключаться между совпадающими разделителями. Это работает как с разделителями символов (например, '(' и ')'), так и с разделителями слов для таких языков, как Pascal и Verilog, которые используют «начало» и «конец» для разделения блоков. Он также работает для сопоставления начальных и конечных тегов в XML. Если слово неизвестно, **^ G** начинает поиск со словом, перемещенным в строку поиска.

Чтобы **^ G** работала с разделителями слов, курсор должен быть расположен на первой букве слова. Таким образом, в XML, если курсор находится на <в <foo>, он переместится на>. Но если это одна буква «f», он перейдет к соответствующему </foo>. Точно так же в C **^ G** будет переключаться между #if, #else и #endif, но вам нужно поместить курсор на букву, а не на '#'.

**^ G** достаточно умен, чтобы пропускать разделители, найденные в цитируемом или закомментированном материале. Вам нужно сообщить JOE, как ваш язык указывает на это: см. Файл **ftyperc,** чтобы увидеть, как это делается.

Ряд опций , которые контролируют поведение **^ G** . Эти параметры определяют, какие комментарии **^ G** можно пропустить:

* c_comment
* cpp_comment
* pount_comment
* semi_comment
* vhdl_comment

Эти параметры определяют, какие типы строк **^ G** можно пропускать:

* single_quoted
* двойные кавычки

Эта опция позволяет аннотированному файлу синтаксиса определять, какой текст можно считать комментариями или строками, которые можно пропустить с помощью **^ G** :

* highlighter_context

Эта опция позволяет использовать файлы синтаксиса для идентификации комментариев и строк, которые следует пропускать при сопоставлении **^ G.**Состояния файла синтаксиса должны быть аннотированы ключевыми словами **string** и **comment,** чтобы это работало.

* text_delimiters

Эта опция предоставляет список совпадающих разделителей слов. Например, «begin = end: if = elif = else = endif» означает, что **^ G** будет переключаться между совпадающими if, elif, else и endif. Он также будет перескакивать между началом и концом.

**^ G** имеет встроенную таблицу для сопоставления разделителей символов - он знает, что **(** идет с **)** .

**^ G** имеет встроенный синтаксический анализатор для обработки сопоставления начального и конечного тегов для XML.

## [Регионы][35]

Если вы хотите переместить, скопировать, сохранить или удалить определенный фрагмент текста, вы можете сделать это с помощью выделенных блоков. Сначала переместите курсор в начало раздела текста, над которым хотите работать, и нажмите **^ KB** . Затем переместите курсор к символу сразу после конца текста, который вы хотите изменить, и нажмите **^ KK** . Текст между **^ KB** и **^ KK** должен быть выделен. Теперь вы можете переместить курсор в другое место в документе и нажать **^ KM,** чтобы переместить туда выделенный текст.   
Вы можете нажать **^ KC,** чтобы сделать копию выделенного текста и вставить ее туда, где находится курсор. **^ KY** для удаления выделенного текста. **^ KW** , записывает выделенный текст в файл. 

Очень полезной командой является **^ K /** , которая фильтрует блок текста с помощью команды UNIX. Например, если вы выберете список слов с помощью **^ KB** и **^ KK** , а затем наберете **^ K / sort** , список слов будет отсортирован. Еще одна полезная команда UNIX для **^ K /** - **tr** . Если вы наберете **^ K / tr az AZ** , все буквы в выделенном блоке будут преобразованы в прописные.

### [Как мне отменить выделение выделенного региона?][36]

После того, как вы закончите с некоторыми операциями с регионом, вы можете просто оставить выделение включенным, если вы не против (но не нажимайте случайно **^ KY** ). Однако, если вас это действительно беспокоит, просто нажмите **^ KB ^ KK** , чтобы выключить выделение.

Начиная с JOE 4.2, вы можете нажать **^ C,** чтобы отменить выбор региона.

### [Новые способы выбора регионов][37]

Классический способ - нажать **^ KB** в начале и **^ KK** в конце. Эти установочные указатели называются markb и markk. После того, как они устанавливаются вы можете перейти к markb с **Esc B** и перейти к markk с **Esc K** .

Новый способ: нажмите Ctrl- **стрелка** вправо, чтобы начать выбор вправо. Каждый раз, когда вы нажимаете Ctrl + **стрелка вправо** , блок расширяется еще на один вправо. Здесь используется простой макрос: "begin_marking, rtarw, toggle_marking".

К сожалению, не существует стандартного способа получить последовательность клавиш, заданную эмулятором терминала, когда вы нажимаете Ctrl- **стрелку вправо** . Вместо этого вы должны сами определить эту последовательность и ввести ее непосредственно в файл joerc. Некоторые примеры приведены для Xterm и gnome-terminal. Нажмите **^ Q** Ctrl - **стрелку вправо** в JOE, чтобы последовательность отображалась на экране. Обратите внимание, что Putty использует **Esc Esc [C,** который не отображается с **^ Q стрелкой вправо** (также **Esc Esc** - это команда установки закладки, поэтому вам нужно отменить привязку, чтобы сделать это в Putty).

Также вы можете нажать Ctrl- **Delete,** чтобы вырезать и Ctrl- **Insert,** чтобы вставить, если последовательность этих клавиш известна.

Мышь также можно использовать для выделения текста, если в JOE включена поддержка мыши.

## [Отступы программных блоков][38]

Режим автоматического отступа переключается с помощью команды **^ TI** . **Joerc** файл обычно настроен так , что файлы с именами , заканчивая .p, .c или .h включена режим автоматического отступа. Когда режим автоматического отступа включен и вы нажимаете **Enter** , курсор будет помещен в тот же столбец, что и первый непробельный символ в исходной строке.

Вы можете использовать **^ K** и **^ K.**команды для сдвига блока текста влево или вправо. Если при подаче этих команд подсветка не установлена, будет выбран программный блок (обозначенный отступом), в котором находится курсор, и будет перемещен последующими **клавишами ^ K** и **^ K.** команды.

Число столбцов, на которые смещаются эти команды, и символ, используемый для сдвига, можно установить с помощью параметров istep и indentc. Эти параметры доступны в меню **^ T.**Кроме того, **^ T =** можно использовать для быстрого выбора из ряда общих значений шага отступа и символа.

У JOE есть ряд дополнительных опций, связанных с программами создания отступов:

* smartbacks   
Включить умную обратную клавишу и вкладку. Когда установлен этот режим, **Backspace** и **Tab** indent или undent в зависимости от значений параметров istep и indentc.
* SmartHome **Дом** и **^ А** ключи первым переместить курсор в начало строки, а затем , если удар снова, на первый непустой символ.
* indentfirst   
Умный дом сначала переходит к первому непустому символу, а не к началу строки.
* очистить При необходимости   
исправить отступ перед перемещением или умным возвратом. Например, если для отступа используется сочетание табуляции и пробелов, а indentc - это пробел, то до операции сдвига отступ будет преобразован во все пробелы.
* guess_indent   
Если установлено, JOE пытается угадать символ отступа и шаг отступа на основе содержимого файла. Алгоритм состоит в том, чтобы найти наибольший общий множитель из трех наиболее распространенных углублений, обнаруженных в файле.

## [Прямоугольный режим][39]

Введите **^ TX,** чтобы **^ KB** и **^ KK** выбирали прямоугольные блоки вместо блоков потока текста. Это также известно как столбчатый режим. Этот режим полезен для перемещения, копирования, удаления или сохранения столбцов текста. Вы также можете фильтровать столбцы текста с помощью команды **^ K /, например,** если вы хотите отсортировать столбец. Также затрагивается команда вставки файла **^ KR** .

Когда выбран режим прямоугольника, также полезен режим замены ( **^ TT** ). Когда выбран режим замены, прямоугольники заменяют существующий текст, а не вставляются перед ним. Также команда удаления блока ( **^ KY** ) очистит выбранный прямоугольник с помощью **пробелов** и **табуляции** вместо его удаления. Режим замены особенно полезен для команды блока фильтра ( **^ K /** ), поскольку он сохраняет исходную ширину выбранного столбца.

## [Режим изображения][40]

Используйте **^ TP** для входа в режим изображения или выхода из него. Режим изображения помогает с рисунками ASCII.

Режим изображения контролирует, как JOE обрабатывает случай, когда курсор проходит за концы строк. Это происходит, когда вы используете клавиши со стрелками вверх или вниз для перемещения курсора с конца длинной строки на короткую.

Если вы попытаетесь ввести символ в этом случае:

Если режим изображения выключен, курсор переместится в конец строки и вставит его туда.

Если включен режим изображения, строка заполняется пробелами, так что символ можно вставить в позицию курсора.

## [Windows][41]

Вы можете редактировать более одного файла одновременно или редактировать два или более разных места одного и того же файла. Для этого нажмите **^ KO** , чтобы разделить экран на два окна. Используйте **^ KP** или **^ KN,** чтобы переместить курсор в верхнее или нижнее окно. Используйте **^ KE,** чтобы отредактировать новый файл в одном из окон. Окно исчезнет , когда вы сохраните файл с **^ KX** или отмените файл с **^ C** . Если вы прерываете файл, который существует в двух окнах, одно из окон исчезает, а не файл.

Вы можете нажать **^ KO** в окне, чтобы создать еще больше окон. Если у вас слишком много окон на экране, но вы не хотите их удалять, вы можете нажать **^ KI** . Это покажет только окно, в котором находится курсор, или, если на экране было только одно окно, попробуйте уместить все скрытые окна на экране. Если окон больше, чем может поместиться на экране, вы можете нажать **^ KN** в самом нижнем окне или **^ KP** в самом верхнем окне, чтобы добраться до них. 

Если вы дали JOE более одного имени файла в командной строке, каждый файл будет помещен в отдельное окно. 

Вы можете изменить высоту окон с помощью команд **^ KG** и **^ KT** .

### [Модель оконной системы][42]

У JOE необычная модель оконной системы. По сути, у вас есть кольцо окон, но на экране может поместиться только часть этого кольца. Окна, которых нет на экране, все еще существуют, они просто прокручиваются. Когда вы нажимаете **^ KN** в нижнем окне экрана, он прокручивает дальнейшие окна с кольца на экран, возможно, позволяя верхнему окну прокручиваться вне поля зрения.

Собственный JOE пытается сохранить каждый загруженный буфер в окне, чтобы пользователи могли найти все буферы, прокручивая окна. Команда **разнесения** ( **^ KI** ) либо расширяет все окна до размера экрана, чтобы на экране помещалось только одно окно, либо сжимает их все настолько, насколько это возможно, чтобы на экране поместилось много окон.

С другой стороны, JOE поддерживает "сиротские" буферы - файлы, загруженные в редактор, но которых нет в окне. **^ C** обычно закрывает окно и отбрасывает буфер, который был в нем. Если вы нажмете **^ C** в последнем оставшемся окне, редактор обычно закроется. Однако, если есть лишние буферы, **^ C** загрузит их в это последнее окно, чтобы дать вам возможность явно отменить их. Если в командной строке задана опция **orphan** , как в **joe -orphan * .c** , то JOE загружает в окно только первый файл, а все остальные **оставляют без внимания** .

**orphan** также управляет тем, создает ли команда редактирования **^ KE** новое окно для вновь загруженного файла или повторно использует текущее окно (осиротев предыдущее его лицо).

Команда **bufed** запрашивает имя буфера для переключения в окно. В его списке завершения будут показаны все буферы, включая сиротские и буферы, которые появляются в других окнах. **Esc V** и **Esc U** (команды **nbuf** и **pbuf** ) позволяют циклически перебирать все буферы в одном окне.

Windows поддерживает стек агентов для поддержки функции всплывающего окна оболочки. Когда всплывающее окно закрывается, предыдущий буфер возвращается в окно.

## [Скретч-буферы][43]

Временные буферы - это буферы, которые JOE не беспокоит, пытаясь сохранить. JOE не будет запрашивать сохранение измененных рабочих буферов. Всплывающие окна оболочки, журнал запуска, окна компиляции и сообщений grep - это временные буферы. Вы можете создать свой собственный рабочий буфер с помощью команды **scratch** .

Следующие команды загружают рабочие буферы:

* **showlog** Показать журнал запуска
* **mwind** Показать окно сообщений (компилировать / grep сообщения от команд **Esc C** и **Esc G** ).

## [Макросы клавиатуры][44]

Макросы позволяют записывать серию нажатий клавиш и воспроизводить их нажатием двух клавиш. Это полезно для автоматизации повторяющихся задач. Чтобы начать запись макроса, нажмите **^ K [с** последующим числом от 0 до 9. В строке состояния отобразится (Запись макроса ...). Теперь введите серию нажатий клавиш, которые вы хотите повторять. Команды, которые вы вводите, будут иметь свои обычные эффекты. Нажмите **^ K],** чтобы остановить запись макроса. Нажмите **^ K,** а затем номер, в который вы записали макрос, чтобы выполнить одну итерацию нажатий клавиш. 

Например, если вы хотите поставить «**» перед несколькими строками, вы можете ввести:

**^ K [0 ^ A ******^ K]**

При этом начинается запись макроса, курсор перемещается в начало строки, вставляется «**», перемещается курсор на одну строку вниз, а затем запись завершается. Поскольку мы включили нажатия клавиш, необходимые для размещения курсора на следующей строке, мы можем многократно использовать этот макрос, не перемещая курсор самостоятельно, о чем вы всегда должны помнить при записи макроса.

### [Подпрограммы макросов клавиатуры][45]

Если вы обнаружите, что сам макрос, который вы записываете, содержит повторяющийся набор нажатий клавиш, вы можете записать макрос внутри макроса, если вы используете другой номер макроса. Также вы можете выполнять ранее записанные макросы из новых макросов.

### [Приостановить запрос][46]

Если ваш макрос включает подсказку для ввода пользователем, и вы хотите, чтобы пользователь заполнял подсказку каждый раз при выполнении макроса, нажмите **^ K?**в том месте в записи макроса, где требуется действие пользователя. В этот момент ввод с клавиатуры не записывается. Когда пользователь завершит запрос, запись макроса продолжится.

Когда макрос выполняется, проигрыватель макросов приостанавливается в точке, где **^ K?**был введен, чтобы разрешить ввод данных пользователем. Когда пользователь завершает запрос, игрок продолжает выполнение оставшейся части макроса.

### [Повторение][47]

Вы можете использовать команду повторения **^ K \** , чтобы повторить макрос или любую другую команду редактирования или даже обычный символ, указанное количество раз. Нажмите **^ K \** , введите количество раз, которое вы хотите повторить команду, и нажмите **Enter** . Следующая команда редактирования, которую вы сейчас дадите, будет повторяться столько раз. Например, чтобы удалить следующие 20 строк текста, введите:

**^ К \ 20****^ Y**

## [Макросы и команды][48]

Макрос - это список команд, разделенных запятыми. Когда макрос выполняется, каждая команда выполняется до тех пор, пока не будет достигнут конец списка или одна из команд не завершится ошибкой (ненулевое возвращаемое значение из команды). Неудачные команды издают звуковой сигнал, если у вас включены звуковые сигналы ( **^ TB** ).

Нажмите **Esc D,** чтобы вставить текущий набор макросов клавиатуры в виде текста в текущий буфер. Например, макрос вставки «**» выше выглядит так:

    home,"**",dnarw    ^K 0    Macro 0
    

Вы можете вставить это в свой файл .joerc и изменить последовательность клавиш ( **K 0** ) на что-то более постоянное.

### [Определите свой собственный][49]

Вы можете привязать макросы к последовательностям клавиш или определить свои собственные именованные макросы в файле joerc. Например, это определит макрос с именем **foo** :

    :def foo eof,bol
    

**foo поместит** курсор в начало последней строки файла. **eof** переходит в конец файла. **bol** переходит в начало строки. После того, как макрос был назван таким образом, он появится в списке завершения командной строки **Esc X.**

### [Командная строка][50]

Вы можете выполнить макрос напрямую, набрав его в командной строке. Нажмите **Esc X,** чтобы открыть командную строку. Нажмите **Tab** в этом приглашении, чтобы просмотреть список всех доступных команд.

Вот [полный список команд][51] .

### [Макро модификатор не останавливается][52]

Иногда вы ожидаете, что команды будут иногда давать сбой, но хотите, чтобы остальные команды в списке все равно выполнялись. Чтобы отметить команду, которая может завершиться ошибкой, добавьте к ней "!". Например, вот макрос, который открывает страницу в окне выше:

    prevw,pgdn!,nextw
    

Если prevw не удается, макрос прерывается как обычно. Даже если pgdn завершается неудачно (уже в конце буфера), nextw будет выполнен, так что курсор вернется в исходное окно.

### [Модификаторы повторения аргументов макроса][53]

Повторяющиеся аргументы можно указать с помощью **^ K \** . Когда команда выполняется с аргументом повторения, она выполняется повторно указанное количество раз. Если аргумент повторения отрицательный, вместо него выполняется противоположная команда (если таковая существует). Например, если вы повторите «rtarw» -3 раза, «ltarw» будет повторяться 3 раза. Если отрицательный аргумент дается для команды, у которой нет противоположности, аргумент повторения игнорируется.

Обычно, если для макроса указан аргумент повторения, макрос просто повторяется заданное количество раз. Если указан отрицательный аргумент, аргумент игнорируется.

Иногда вы хотите разрешить отрицательные аргументы для макросов и изменить их поведение. Для этого постфиксируйте каждую команду в макросе, которая должна быть заменена на противоположную для отрицательных аргументов с помощью '-'. Например, вот макрос следующего окна страницы вниз:

    prevw,pgdn-!,nextw
    

Теперь, если вы выполните это с аргументом -2, он будет повторяться дважды, но pgup будет выполнен вместо pgdn. (обратите внимание, что после каждой команды можно разместить несколько постфиксов).

Иногда, когда макросу передается аргумент повторения, вы хотите, чтобы повторялась только одна из команд в списке, а не весь макрос. Это можно обозначить следующим образом:

    prevw,pgdn#!,nextw
    

Если это выполняется с аргументом 2, prevw выполняется один раз, pgdn выполняется дважды, а nextw выполняется один раз.

Наконец, еще более сложная семантика может быть выражена с помощью команды «if»:

    if~,"arg<0",then,
        ltarw,
    else,
        rtarw,
    endif
    

Когда макрос выполняется, математическая переменная "arg" устанавливается в заданный аргумент повторения. Переменная "argset" устанавливается в значение true, если пользователь устанавливает аргумент, даже если он равен 1. Если аргумент не был указан, argset имеет значение false.

Если какая-либо команда в списке помечена ~ (если указано выше), макрос не повторяется, даже если есть аргумент. Однако 'arg' по-прежнему установлен на заданное количество повторов.

### [взаимодействие 'psh' / 'query'][54]

Команда 'psh' сохраняет позиции **^ KB** и **^ KK** в стеке. Когда макрос завершается (или когда вызывается команда pop), позиции восстанавливаются.

Команда 'query' приостанавливает выполнение макроса до завершения текущего диалога. Он также приостанавливает автоматическое «всплывающее окно», которое происходит в конце макроса - поэтому, если макрос завершается в диалоговом окне, вы часто хотите вызвать «запрос», чтобы предотвратить слишком раннее восстановление позиций **^ KB****^ KK** .

## [Поиск тегов][55]

Если вы редактируете большую программу на языке C с большим количеством исходных файлов, вы можете использовать программу **ctags** для создания файла **тегов** . Этот файл содержит список программных символов, а также файлы и позиции, в которых эти символы определены.

Сначала создайте файл тегов с помощью программы "ctags". Например:

    ctags *.c *.h
    

Это создаст в текущем каталоге файл с именем «теги».

JOE ищет файл «тегов» в текущем каталоге. Если его нет, он попытается открыть файл, указанный в переменной среды TAGS.

Пути в файле тегов всегда указываются относительно местоположения самого файла тегов.

Файл тегов содержит список местоположений определения идентификаторов в одном из следующих форматов:

    identifier filename /search-expression/[;comments]
    
    identifier filename ?search-expression?[;comments]
    
    identifier filename line-number[;comments]
    

Некоторые версии ctags включают имена классов в идентификаторы:

    class::member
    

В этом случае JOE будет соответствовать любой из этих строк:

    member
    ::member
    class::member
    

Некоторые версии ctags включают имя файла в идентификатор:

    filename:identifier
    

В этом случае JOE найдет идентификатор, только если имя буфера совпадает с именем файла.

Выражение поиска - это регулярное выражение vi, но JOE поддерживает только следующие специальные символы:

    ^ at the beginning means expression starts at beginning of line
    
    $ at the end means expression ends at end of line
    
    \x quote x (suppress meaning of /, ?, ^ or $)
    

Введите **^ K;**для вызова подсказки поиска тегов. Если курсор находился на идентификаторе, подсказка загружается с ним заранее. В этом приглашении работает автозавершение табуляции (для поиска дополнений используется файл тегов).

Когда вы нажимаете **Enter** , начинается поиск тегов:

Если есть одно и только одно совпадение, JOE перейдет непосредственно к определению.

Если есть несколько совпадений, то поведение контролируется опцией notagsmenu. Если notagsmenu включено, JOE переходит к первому определению. Если вы нажмете **^ K;**снова, прежде чем нажимать какие-либо другие клавиши, JOE переходит к следующему определению и так далее. Эту функцию также выполняет команда tagjump.

Если notagsmenu отключено, JOE отображает меню всех совпадений. Вы выбираете тот, который хотите, и ДЖО прыгает к нему. Если вы нажмете **^ K;**еще раз, прежде чем нажимать любые другие клавиши, то же меню снова появляется с курсором, оставленным в исходном месте.

Вы можете нажать **^ K -,** чтобы переместить курсор обратно в исходное положение перед поиском тегов (часто **^ C также** будет работать).

Поскольку **^ K;**загружает файл определения в текущее окно; вы, вероятно, захотите сначала разделить окно с помощью **^ KO** , чтобы загрузить как исходный файл, так и файл определения.

## [Калькулятор][56]

JOE имеет встроенный калькулятор , который может быть вызван с **Esc M** .

### [Математические функции][57]

sin, cos, tan, exp, sqrt, cbrt, ln, log, asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh, int, floor, ceil, abs, erf, erfc, j0, j1, y0, y1

### [Переменные][58]

* e   
Установите на 'e'
* пи   
Установите на 'пи'
* top   
Установить на номер строки верхней строки окна
* lines   
Установить количество строк в файле
* line   
Установить на текущий номер строки
* col   
Установить текущий номер столбца
* byte   
Установить на текущий номер байта
* size   
Установить размер буфера
* height   
Установить на высоту окна
* width   
Установить ширину окна
* char   
Устанавливается в ASCII значение символа под курсором
* markv   
Истинно, если есть допустимый набор блоков (^ KB ... ^ KK)
* rdonly   
Истинно, если файл доступен только для чтения
* arg   
Текущий аргумент повтора
* argset   
Истинно, если был дан повторный аргумент
* is_shell   
Истинно, если выполняется в активном окне оболочки
* no_windows   
Кол-во окон буфера на экране
* ans   
Результат предыдущего выражения

### [Команды][59]

* hex   
Hex режим отображения
* Декабрь   
режим отображения Десятичного
* ins   
Вставить ans в буфер
* сумма   
Сумма чисел в блоке
* cnt   
Подсчет чисел в блоке
* avg   
Среднее значение чисел в блоке
* dev   
Стандартное отклонение чисел в блоке
* eval   
Оценивает математические выражения в блоке (или во всем файле, если блок не задан).
* joe (...)   
Выполнить макрос JOE (аргумент в том же формате, что и макросы файла joerc). Возвращаемое значение макроса JOE возвращается (для успешного выполнения макроса верните истину (ненулевое значение)).

Например:

    joe(sys,"[ 1 == 1 ]",rtn)
    

([1 == 1]) - это команда оболочки. «[» является синонимом команды «test» UNIX.

Возвращает истину.

Помните: аргумент макрос-команды JOE "if" является математическим выражением. Так, например, макрос:

    if,"joe(sys,\"[ 1 == 1 ]\",rtn)",then,"TRUE",endif
    

Вводит в буфер TRUE.

### [Операторы:][60]

* ! x   
Логическое не от x.
* x ^ y   
Возвести x в степень y.
* a * b   
Умножить.
* а / б   
разделить.
* a% b   
Модуль.
* a + b   
Добавить.
* ab   
Вычесть.
* a <b   
Истинно, если a меньше b.
* a <= b   
Истинно, если a меньше или равно b.
* a> b   
Истинно, если a больше b.
* a> = b   
Истинно, если a больше или равно b.
* a == b   
Истинно, если a равно b.
* a! = b   
Истинно, если a не равно b.
* a && b   
Истинно, если истинны и a, и b.
* a || b   
Истинно, если ether a или b истинны.
* a? b: c   
Если a истинно, верните b, иначе верните c.
* a = b   
Назначьте b на a.
* a: b   
Выполните a, затем выполните b.

&&, || и ? : работает как в C и sh, но до побочных эффектов: если левая часть && ложна, правая часть не оценивается.

: разделитель выражений.

## [Окна оболочки][61]

Нажмите **^ K ',** чтобы запустить командную оболочку в одном из окон JOE. Когда курсор находится в конце окна оболочки (используйте **^ KV,** если это не так), все, что вы вводите, передается оболочке вместо буфера. Любой вывод оболочки или команд, выполняемых в оболочке, добавляется к окну оболочки (курсор будет следовать за этим выводом, если он находится в конце окна оболочки). Эта команда полезна для записи результатов команд оболочки - например, вывода **make** , результата **grep** ping набора файлов для строки или списков каталогов из сеансов **FTP** . Помимо вводимых символов, клавиши **^ C** , **Backspace** , **Del** ,**Return** и **^ D** передаются в оболочку. Введите команду **выхода** оболочки, чтобы остановить запись вывода оболочки. Если вы нажмете **^ C** в окне оболочки, когда курсор не находится в конце окна, оболочка будет **уничтожена** .

Если вы используете Bash, вы можете нажать: **^ Q Стрелка вверх** и **^ Q Стрелка вниз,** чтобы прокрутить буфер истории Bash. Другие клавиши тоже работают: попробуйте **^ Q ^ A,** чтобы перейти в начало строки, или **^ Q ^ E,** чтобы перейти в конец строки. К сожалению, JOE эмулирует только тупой терминал, поэтому вам придется проявить много воображения, чтобы выполнить любое редактирование, помимо нажатия на клавишу Backspace.

Как правило, в оболочку отправляется любой символ, заключенный в **^ Q.**

Также посылается оболочке: **Tab** , **Backspace** , **Enter** , **^ C** и **^ D** .

## [Всплывающие окна оболочки][62]

Нажмите F1 - F4, чтобы открыть и переключаться между окнами оболочки.

Всплывающие окна оболочки используют полноценный эмулятор терминала, поэтому при вводе «man ls» он форматируется правильно (он работает достаточно хорошо, чтобы можно было использовать некоторые интерактивные программы). Даже в этом случае окно оболочки по-прежнему является буфером редактирования.

Старое окно оболочки (без эмуляции терминала) все еще существует: используйте **^ K ',** чтобы вызвать его как обычно. Это полезно для просмотра управляющих последовательностей, создаваемых программой.

Во всплывающих окнах оболочки запущенной программе передается больше ключей, чем в старой. В файле joerc есть раздел: vtshell, в котором можно указать, какие именно. В частности, программе передаются клавиши со стрелками и Ctrl-C. Это означает, что вы можете легко перемещаться по истории bash с помощью клавиш со стрелками или прерывать программы обычным способом с помощью Ctrl-C.

С другой стороны, потеря Ctrl-C означает, что не так очевидно, как закрыть окно. Один из способов - переместить курсор с точки ввода данных оболочки (с помощью Ctrl-P), а затем нажать Ctrl-C. Другой - ударить **^ KQ** . Наконец, вы можете ввести «pop» в командной строке.

Если вам нужно передать в оболочку ключ, который обычно использует JOE, укажите его в кавычках. Например, если вы вызываете "emacs -nw" в окне оболочки, вы можете выйти из него с помощью:

    ^Q ^X ^C
    

Чтобы быстро переместить курсор обратно в точку, где данные вводятся в оболочку, нажмите **^ KV** .

Когда вы открываете окно оболочки, создается сценарий запуска, специфичный для JOE. Он находится в /etc/joe/shell.sh (также /etc/joe/shell.csh). Он содержит несколько псевдонимов, которые позволяют управлять JOE с помощью поддельных команд оболочки. Пока у меня есть эти команды:

* очистить   
окно стирания оболочки (удалить содержимое буфера)
* файл joe   
редактировать файл в JOE
* математика 1 + 2   
вычислить уравнение с помощью калькулятора JOE
* cd xyz   
сменить каталог, поддерживать JOE в актуальном состоянии
* markb то   
же, что и ^ KB
* markk то   
же, что и ^ KK
* отметить команду   
выполнить команду оболочки, отметить ее вывод
* команда parse   
выполнить команду оболочки, проанализировать ее вывод для имен файлов и номеров строк (для поиска или grep)
* команда парсера   
выполнить команду оболочки, проанализировать ее вывод на наличие ошибок (для gcc)
* релиз   
релиз проанализированных ошибок
* поп   
отклонять оболочки окна ( так же , как ^ KQ)

Они работают путем выдачи управляющей последовательности, распознаваемой эмулятором терминала: **Esc {joe_macro}** . Когда это получено, макрос выполняется. В целях безопасности таким образом могут выполняться только макросы, определенные в файле joerc, которые начинаются с "shell_".

### [Случаи использования][63]

У всплывающих окон оболочки есть несколько хороших вариантов использования:

* Используйте его для просмотра страниц руководства

Нажмите F1 и введите "man fopen". Используйте 'b' ('u') и пробел, чтобы контролировать _больше_ (или _меньше_ ) при просмотре руководства. Вы можете оставить руководство на экране в одном окне, а редактировать в другом окне.
* Используйте его для переключения каталогов

Нажмите F1 и перейдите в каталог, используя _компакт-диск_ . Как только вы окажетесь в нужном месте, нажмите **^ KE,** чтобы загрузить файл (или введите «редактировать файл» из оболочки).
* Используйте его вместе с анализатором ошибок для поиска файлов

Нажмите F1 и перейдите в каталог. Используйте grep или find (или оба) для создания списка файлов):

            parse grep -n FIXME *.c
    

Или же:

            markb; find . | xargs grep -n FIXME; markk; parse
    

(Учтите, что этого нельзя сказать:

            parse find . | xargs grep -n FIXME
    

... проблема в том, что в качестве аргументов команде синтаксического анализа передаются только слова слева от символа вертикальной черты).

Теперь используйте **^ P,** чтобы поместить курсор на одну из строк списка. Нажмите **Esc Пробел,** чтобы JOE отредактировал файл и перешел к указанной строке (также вы можете использовать **Esc -** и **Esc =** для перехода по списку).

* Используйте его вместе с поиском и заменой для редактирования большого количества файлов.

Как только у JOE будет список файлов (сверху), используйте поиск и замените опцией 'e', ​​чтобы просмотреть их все:

            ^K F
               Find: <text>
               Options: re
               Replace: <replacement text>
    

* Создайте свой проект

Легко фиксируйте ошибки из сборки с помощью:

            parserr make
    

Нажмите **Esc =** и **Esc,** чтобы просмотреть ошибки.

### [Как это устроено..][64]

* Появился новый режим «анси». ( **Esc в** режиме ANSI). Когда этот режим включен, программа обновления экрана скрывает escape-последовательности, которые находятся в буфере. В противном случае вы получите большой беспорядок из последовательностей, окружающих цветной вывод из ls.
* Появился новый встроенный синтаксис: «ansi». ( **^ TY** ansi). Этот синтаксис анализирует последовательности управления цветом ANSI, чтобы текст был окрашен.
* Существует эмулятор терминала для интерпретации управляющих последовательностей из программы оболочки. Он эмулирует терминал, изменяя содержимое буфера редактирования.
* Когда размер окна редактирования изменяется, мы сообщаем об этом оболочке, выдав TIOCSSIZE или TIOCSWINSZ ioctl. Таким образом, программа, работающая в оболочке, знает размер окна.

## [Компилятор и парсеры grep / find][65]

В JOE есть два парсера, которые можно использовать для создания списка ошибок (списка имен файлов / номеров строк).

Команда "parserr" анализирует весь буфер или, если блок установлен, только выделенный блок для сообщений об ошибках компилятора. Сообщения должны быть в таком формате:

    <junk> file.name <junk> line-number <junk> : <junk>
    

Имя файла должно состоять из цифр, букв, '/', '.' и '-'. Должен быть хотя бы один ». в этом. Где-то после номера строки должно быть двоеточие. Строки не в этом формате игнорируются.

Команда «gparse» анализирует весь буфер или, если блок установлен, только выделенный блок для получения списка имен файлов или имен файлов с номерами строк из «grep -n», «find» и подобных программ.

    filename
    
    filename:<junk>
    
    filename:line-number:<junk>
    

Когда у JOE есть список ошибок, вы можете сделать с ним несколько вещей:

* Перейдите к файлам / местоположениям в списке с помощью **Esc -** и **Esc =**
* Выполняйте поиск и замену во всех файлах в списке с помощью опции поиска и замены "e".
* Очистите список с помощью команды «release».

Кроме того, вы можете использовать **Esc Пробел** (команда «перейти»), чтобы проанализировать строку, на которой находится курсор, и перейти к проанализированному имени файла и номеру строки. 'jump' использует синтаксический анализатор grep / find, если 'parserr' не был ранее запущен в буфере.

### [Grep-find][66]

Нажмите **Esc G,** чтобы вызвать подсказку. Введите команду, которая приводит к именам файлов с номерами строк, например: 'grep -n fred * .c'. Это перечислит все экземпляры 'fred' в файлах * .c. Для получения номеров строк вам понадобится '-n'.

Теперь вы можете нажать **Esc Пробел** на одной из строк, чтобы перейти к выбранному файлу. Также вы можете использовать **Esc =** и **Esc -** для перехода по каждой строке.

### [Компилировать][67]

Нажмите **Esc C,** чтобы сохранить все измененные файлы, а затем вызовите приглашение компиляции. Введите команду, которую вы хотите использовать для компилятора (обычно «make -w»). Компилятор будет работать в окне оболочки. Когда он будет завершен, результаты будут проанализированы.

Флаг '-w' должен быть установлен для make, чтобы он печатал сообщения всякий раз, когда меняет каталог. Сообщение имеет следующий формат:

    make[1]: Entering directory `/home/jhallen/joe-editor-mercurial/joe'
    

Если есть какие-либо ошибки или предупреждения от компилятора, вы можете нажать **Esc Пробел** в одной из строк, чтобы перейти к выбранному файлу. Также вы можете использовать **Esc =** и **Esc -** для перехода по каждой строке.

## [Подсветка синтаксиса][68]

Для включения выделения используйте **^ TH** .

Чтобы выбрать синтаксис, используйте **^ TY** . Вы можете нажать **Tab****Tab** в приглашении для завершения списка.

JOE пытается определить используемый синтаксис на основе имени и содержимого файла. Файл конфигурации / etc / joe / ftyperc содержит определения.

Каждый синтаксис определяется файлом, находящимся в / usr / share / joe / syntax /.

## [Как работает подсветка синтаксиса JOE][69]

_из [c.jsf][70] , немного изменен_

Детерминированный конечный автомат, который выполняет лексический анализ целевого языка, предоставляется в файле синтаксиса. (Это «язык ассемблера» подсветки синтаксиса. В принципе, для преобразования синтаксиса NFA регулярных выражений в этот формат можно использовать отдельную программу).

Каждое состояние начинается с:

    :<name> <color-name> <context>
    

это название штата.

это цвет, используемый для символов, съеденных государством (на самом деле символ для определяемого пользователем цвета).

сообщает JOE, является ли текущий символ частью комментария или строки. Это позволяет JOE пропускать комментарии и строки при сопоставлении символов, таких как круглые скобки. Чтобы использовать эту функцию, параметр highlighter_context необходимо применить к файлам, выделенным соответствующим синтаксисом. Чтобы применить эту опцию, добавьте ее в ftyperc для этих файловых записей.

Допустимые контексты:

* комментарий Этот символ является частью комментария. Пример: / * комментарий * /
* строка Этот символ является частью строки. Примеры: "строка" 'c' 'строка'

Сами разделители комментариев и строк должны быть помечены соответствующим контекстом. Контекст считается частью цвета, поэтому параметры recolor = -N и recolormark применяют контекст к предыдущим символам.

Первое определенное состояние - это начальное состояние.

Внутри состояния определите переходы (переходы) в другие состояния. Каждый прыжок имеет вид:

        <character-list> <target-state-name> [<option>s]
    

Есть три способа указать s, либо ***** для любого символа, не указанного иначе, **%** или **&** для соответствия символу в буфере соответствия разделителя ( **%** точно соответствует сохраненному символу, а **&** соответствует противоположному символу, например (будет соответствовать), когда используется **&** ), либо буквальный список символов в кавычках (допустимые диапазоны и управляющие последовательности: см. [escape-последовательности][71] ). Когда следующий символ совпадает с любым в списке, выполняется переход к целевому состоянию, и символ съедается (мы переходим к следующему символу файла, который нужно раскрасить).

Переход * должен быть первым переходом, указанным в состоянии.

Есть несколько вариантов:

* **noeat** - не есть персонажа, вместо этого **передать** его в следующее состояние

                  (this tends to make the states smaller, but be careful: you
                  can make infinite loops).  'noeat' implies 'recolor=-1'.
* **recolor = -N** - перекрасить последние N символов в цвет

                  target-state.  For example once /\* is recognized as the
                  start of C comment, you want to color the /\* with the C
                  comment color with recolor=-2.
* **mark** - Отметить начало региона текущей позицией.
* **markend** - Отметить конец региона.
* **recolormark** - **перекрасить** все символы в отмеченной области на

                  the color of the target-state.  If markend is not given,
                  all of the characters up to the current position are recolored.
                  Note that the marked region can not cross line boundaries and
                  must be on the same line as recolormark.
* **buffer** - начать копирование символов в строковый буфер, начиная с этого

                  one (it's OK to not terminate buffering with a matching
                  'strings', 'istrings' or 'hold' option- the buffer is limited
                  to leading 23 characters).
* **save_c** - сохранить символ в буфере совпадения разделителей.
* **save_s** - копировать строковый буфер в буфер соответствия разделителя.
* **строки** - следует список строк. Если буфер соответствует любому из

                  given strings, a jump to the target-state in the string list
                  is taken instead of the normal jump.
* **istrings** - То же, что и строки, но регистр не **учитывается** .

                  Note: strings and istrings should be the last option on the
                  line.  They cause any options which follow them to be ignored.
* **hold** - Остановить буферизацию строки - будущие 'строки' или 'istrings' будут

                  look at contents of buffer at this point.  Useful for distinguishing
                  commands and function calls in some languages 'write 7' is a command
                  'write (' is a function call- hold lets us stop at the space and delay
                  the string lookup until the ( or 7.

Формат списка строк:

        "string"   <target-state> [<options>s]
        "string"   <target-state> [<options>s]
        "&"        <target-state> [<options>s]   # matches contents of delimiter match buffer
        done
    

(разрешены все вышеперечисленные параметры, кроме «strings», «istrings» и «noeat». noeat всегда подразумевается после сопоставленной строки).

Странность: цвета имеют только состояния, а не переходы. Это означает, что иногда вам нужно создавать фиктивные состояния с помощью

        *    <next-state>    noeat
    

просто чтобы получить спецификацию цвета.

Буфер соответствия разделителю предназначен для perl и оболочки: регулярное выражение в perl может быть s <..> (...), а в оболочке вы можете сказать: << EOS ....... EOS. Идея состоит в том, что вы захватываете первый разделитель в буфер соответствия (<или первый «EOS»), а затем сопоставляете его со вторым с помощью «&» в строке или списке символов.

### [Подпрограммы][72]

Конечные автоматы выделения теперь могут выполнять вызовы подпрограмм. Это работает путем создания экземпляра шаблона: вызываемый конечный автомат включается в ваш текущий конечный автомат, но изменяется так, что адрес возврата указывает на вызываемый. По-прежнему нет стека времени выполнения (состояние представлено как одно целое число плюс сохраненная строка-разделитель).

Рекурсия разрешена, но она ограничена 5 уровнями.

**Примечание:** этот предел рекурсии устарел. Подпрограммы теперь используют стек, поэтому глубина вызова безгранична.

Чтобы вызвать подпрограмму, используйте опцию 'call':

        "\""    fred    call=string(dquote)
    

Вызывается подпрограмма под названием 'string', и переход к 'fred' игнорируется. Параметр 'dquote' передается подпрограмме.

Если вы используете перекрашивание вместе с вызовом, используется цвет первого состояния подпрограммы.

Сама подпрограмма возвращается к вызывающей стороне следующим образом:

        "\""    whatever    return
    

Если мы находимся в подпрограмме, она возвращается в целевое состояние вызова («fred» в приведенном выше примере). Если мы не находимся в подпрограмме, она переходит на «что угодно».

Если вы используете перекрашивание вместе с возвратом, используется цвет из возвращенного состояния («fred» в приведенном выше примере).

Есть несколько способов разграничения подпрограмм, которые проявляются в том, как они вызываются. Вот варианты:

* **call = string ()** - файл с именем string.jsf является подпрограммой.

                            The entire file is the subroutine.  The starting
                            point is the first state in the file.
* **call = library.string ()** - файл с именем library.jsf содержит подпрограмму.

                            The subroutine within the file is called string.
* **call = .string ()** - В текущем файле есть подпрограмма с именем string.

Когда подпрограмма находится внутри файла, но не целиком, она разделяется следующим образом:

    .subr string
    
    . . . states for string subroutine . . .
    
    .end
    

Флаги опций могут быть переданы подпрограммам, которые управляют директивами препроцессора. Например:

    .ifdef dquote
        "\""    idle    return
    .endif
    .ifdef squote
        "'"     idle    return
    .endif
    

.else также доступен. .ifdefs могут быть вложенными.

### [Цветовые схемы][73]

Цветовые _классы_ объявляются в верхней части каждого файла синтаксиса, и на них ссылаются из каждого состояния. Раньше цвета указывались рядом с каждым классом в файлах синтаксиса, но теперь они глобально определяются цветовыми схемами. Файлы синтаксиса будут отображать все цвета, относящиеся к их языкам, объявив их, при необходимости ссылаясь на другие классы в случае, если класс не указан в цветовой схеме. Например, это типично:

    =Constant
    =String +Constant
    =Number +Constant
    

Как Stringи Numberклассы могут быть определены по цветовой гамме. Если это не так, каждый вернется к Constant, что логически является надмножеством строк и чисел. В объявлении класса можно ссылаться на несколько классов; JOE выберет первое, что определено.

Таким образом схемы могут определять широкий и общий набор классов цветов, а файлы синтаксиса могут фильтровать их по классам цвета, применимым к их языкам. Это предполагает, что синтаксис и цветовые схемы соответствуют определенному соглашению, которое изложено в **syntax / CLASSES.md** .

### [Файлы цветовой схемы][74]

Файлы цветовой схемы разделены на разделы в зависимости от количества цветов, доступных терминалу для поддержки, например, 256-цветные терминалы против 88-цветных терминалов против терминалов с поддержкой [24-битного цвета][75] . Каждый раздел начинается с .colorsдирективы:

    .colors 256
    # 256-color terminal section
    .colors *
    # Truecolor terminal section
    

Приведенная выше схема не загрузится на 16-цветной терминал. JOE проверит, установлено ли для COLORTERMпеременной среды значение 24bitили truecolorопределит, поддерживает ли терминал 24-битный цвет, из-за того, что terminfo в настоящее время не поддерживает эту поддержку. В Windows JOE автоматически поддерживает 24-битный цвет.

Цвета окружения указываются как таковые:

    -text <fg>/<bg> <attributes>
    

Где <fg>и <bg>являются необязательными, и могут быть любым из:

* Названия цветов: белый, голубой, пурпурный, синий, желтый, зеленый, красный или черный, БЕЛЫЙ, СИНИЙ, ПУРПУРНЫЙ, СИНИЙ, ЖЕЛТЫЙ, ЗЕЛЕНЫЙ, КРАСНЫЙ или ЧЕРНЫЙ (где цвета в верхнем регистре - это версии с высокой интенсивностью из 16 цветных терминалов. ).
* default для цвета переднего плана или фона терминала по умолчанию.
* Номера цветов: 0-255 цветов xterm
* Спецификации RGB в стандартной $RRGGBBформе (только в 24-битном разделе).

Атрибуты могут быть bold, inverse, blink, dim, underline, и italic.

Можно изменить ряд цветов окружения:

* -text указывает текст среды по умолчанию.
* -status определяет цвет строки состояния.
* -selection указывает цвет, используемый для выбора.
* -help определяет цвет фона текста справки.
* -menu указывает цвет неактивного пункта меню.
* -menusel определяет цвет активного пункта меню.
* -prompt указывает цвет подсказки.
* -message определяет цвет сообщения.
* -linum определяет цвет в полосе для номеров строк.
* -curlinуказывает текущий цвет линии (если hilineон включен).
* -curlinumуказывает цвет номера текущей строки (если hilineон включен).

Не все это указывать. -textпо умолчанию используются цвета переднего плана / фона терминала по умолчанию. Каждый другой получит значение -text(плюс inverseв некоторых случаях), если оно не указано.

При использовании всплывающих окон JOE переназначает цвета 0-15 на основе цветов, найденных в схеме, указанной с помощью -term <n> __color spec__.

Остальная часть файла - это классы цветов, которые отображаются в цвета синтаксиса. Цветовые классы могут быть установлены либо:

    =ClassName <color spec>
    =syntaxname.ClassName <color spec>
    

Во втором случае цвет будет применяться только к указанному синтаксису.

Наконец, макросы могут быть определены в файлах цветовой схемы, чтобы упростить их обслуживание. Например:

    .set dark_blue 66
    # ...
    =Define [dark_blue]
    

Ссылки на dark_blueдолжны быть заключены в скобки, и их значения будут заменены простой заменой строки перед анализом строки (что означает, что макросы могут содержать любой текст, а не только значения цвета).

## [Файл joerc][76]

**Параметры ^ T** , экраны справки и последовательность клавиш для привязки команд редактора определены в файле инициализации JOE. Если вы сделаете копию этого файла (который обычно находится в **/ etc / joe / joerc** ) в **$ HOME / .joerc** , вы можете настроить эти параметры по своему вкусу. Синтаксис файла инициализации должен быть достаточно очевидным, и в нем есть дальнейшие инструкции.

В файле **joerc** есть директива для включения другого файла (: include). Эта возможность используется для включения файла с именем **ftyperc** (обычно находится в **/ etc / joe / ftyperc** ). **В ftyperc** есть таблица типов файлов, которая определяет, какие локальные параметры (включая синтаксис для подсветки) применяются к каждому типу файлов.

### [Последовательность загрузки файла инициализации][77]

Если путь к файлу инициализации начинается с '/' (вы можете указать это с помощью директивы include), JOE пытается загрузить его только по абсолютному пути. В противном случае JOE пытается загрузить файлы инициализации (файл joerc и любые файлы, включенные в него, обычно ftyperc) из трех мест:

* «$ HOME / .joerc» - персонализированный файл joerc пользователя.
* "/ etc / joe / joerc" - системный файл joerc. Точный путь фиксируется во время сборки и определяется параметром скрипта конфигурации --sysconfdir.
* «* joerc» - встроенный файл. Это означает, что JOE ищет файл в таблице файлов, связанных с двоичным файлом JOE (они находятся в файле builtins.c). Предусмотрен встроенный файл joerc, чтобы редактор запускался в случаях, когда системный файл joerc недоступен.

Если системный файл joerc новее, чем файл joerc пользователя, JOE напечатает предупреждение в журнале запуска. Предыдущие версии JOE подсказывали пользователю об этом случае - идея заключалась в том, что JOE может быть непригодным для использования с устаревшим файлом инициализации.

### [разделы файла joerc][78]

**Joerc** файл разбит на несколько разделов:

* Глобальные параметры Параметры, не зависящие от файла, например **noxon** .
* Параметры, зависящие от имени файла и содержимого Параметры, зависящие от типа файла, например **автоотступ** . В этот раздел включен файл **ftyperc** .
* **^ T** Определение системы меню Используйте: defmenu для определения именованного меню макросов. Команда **меню** вызывает конкретное именованное меню. **^ T** - это макрос, который вызывает корневое меню: **menu, "root", rtn** .
* Содержание экрана справки Каждый экран справки назван. Имя используется для реализации контекстно-зависимой справки.
* Привязки клавиш Определены таблицы привязки клавиш. Вы можете определить столько, сколько захотите (вы можете переключиться на конкретную с помощью команды **keymap** ), но необходимо предоставить следующее:


  * **основные** окна редактирования
  * **подсказка** окна подсказки
  * **запрос** Односимвольные запросы запроса
  * **querya Односимвольный** запрос цитаты
  * **querysr Односимвольный** запрос для поиска и замены
  * **оболочка** Shell windows
  * **vtshell** окна оболочки эмулятора терминала

Таблицы привязки ключей могут наследовать привязки от уже определенных таблиц. Это позволяет сгруппировать общие привязки клавиш в одну таблицу, которая наследуется другими.

### [Команда режима][79]

Многие параметры можно контролировать с помощью меню **^ T.**Это меню определено в файле joerc. Каждая опция в меню **^ T** просто выполняет макрос. Обычно макрос - это команда режима. Вы можете выполнить команду режима напрямую с помощью:

    Esc X mode <enter>
    

Нажмите **Tab****Tab** для полного списка всех опций.

### [Команда меню][80]

Эта команда вызывает именованное меню макросов, которое было определено в файле **joerc** .

    Esc X menu <enter>
    

Как обычно, нажмите **Tab****Tab** в приглашении для завершения списка существующих меню.

**^ T** привязан к простому макро- **меню "root", rtn** - он вызывает корень системы меню параметров.

## [Поддержка Xterm Mouse][81]

Есть два уровня поддержки мыши. Параметр -mouse включает первый уровень, который будет работать с любым стандартным Xterm. Если также задано -joexterm, поддержка мыши расширена, но вам нужна последняя версия XTerm, и она должна быть ./configured с параметром --enable-paste64.

Когда -mouse установлен, вы можете:

* Щелкните левой кнопкой мыши в текстовом окне, чтобы установить положение курсора. Щелкните левой кнопкой мыши в другом окне, чтобы переместить курсор в другое окно.
* Выделите текст мышью. Щелкните левой кнопкой мыши и перетащите, чтобы выделить текст - это будет похоже на то, как если бы вы использовали **^ KB** и **^ KK,** чтобы отметить его. Щелкните левой кнопкой мыши (но не перетаскивайте), чтобы переместить курсор в другое место. Щелкните средней кнопкой мыши, чтобы скопировать выделенный текст в курсор - это будет похоже на нажатие **^ KC** . Если вы перетащите за край текстового окна, окно будет автоматически прокручиваться, чтобы выделить больше текста. К сожалению, Xterm не отправляет никаких кодов, когда курсор находится за пределами самого фрейма Xterm, поэтому это работает, только если мышь все еще находится внутри фрейма Xterm. Я отправил патч сопровождающему Xterm, чтобы улучшить это, но он еще не принял его.
* Измените размер окон с помощью мыши: щелкните и удерживайте строку состояния, разделяющую два окна, чтобы переместить ее.
* Выберите элементы меню (например, любое меню завершения или меню параметров **^ T** ): щелкните элемент меню, чтобы навести на него курсор. Дважды щелкните элемент меню, чтобы выбрать его (так же, как нажатие клавиши возврата с курсором на нем).
* Если у вашей мыши есть колесико, вращение колесика будет прокручивать окно с курсором.

К сожалению, когда выбрано -mouse, вырезание и вставка между X-окнами не работает, как обычно в окне оболочки (щелкните левой кнопкой мыши и перетащите, чтобы выбрать, средний щелчок, чтобы вставить). Вместо этого вы должны удерживать клавишу Shift, чтобы сделать это: щелкните левой кнопкой мыши, удерживая нажатой клавишу Shift, и перетащите, чтобы выбрать, и щелкните левой кнопкой мыши, удерживая Shift, чтобы вставить. Обратите внимание, что при вставке текста в JOE таким способом возникают проблемы: любые символы `будут перепутаны, потому что` означает цитирование следующего управляющего символа. Кроме того, если включен автоматический отступ, вставленный текст не будет иметь правильный отступ.

**Примечание:** эти проблемы с вставкой были решены в последних версиях JOE.

* JOE включает режим «вставки в скобках» в Xterm, так что вставляемый текст заключен в скобки с escape-последовательностью. Эта последовательность заставляет JOE отключать режимы автоотступа, переноса слов и пробелов для вставки и восстанавливает их после завершения вставки.
* Даже если в эмуляторе терминала нет этого режима вставки в скобках, JOE определяет вставленный текст по времени: если текст поступает сразу (все в одном буфере), предполагается, что текст вставлен, а автоотступ и перенос слов временно отключены.

Когда установлен -joexterm (и у вас есть ./configured Xterm с --enable-paste64):

* Вырезать и вставить правильно интегрированы с X. Текст, выделенный с помощью щелчка левой кнопкой мыши, доступен для вставки в другие окна X (даже если выделенный текст больше, чем текстовое окно). Текст, выделенный в других окнах X, можно вставить в JOE с помощью средней кнопки мыши. Нет проблем с вставкой текста, содержащего `или с автоматическим отступом.

--enable-paste64 позволяет прикладной программе передавать данные выбора в кодировке Base-64 в Xterm и обратно. Программа полностью контролирует, что находится в данных выбора и когда они получены или отправлены.

## [Поддержка Color Xterm][82]

JOE может использовать монохромный Xterm, 8-цветной Xterm, 16-цветной Xterm, 88-цветной Xterm и 256-цветной Xterm. Количество цветов, поддерживаемых Xterm, определяется тем, какие параметры сценария «configure» установлены перед компиляцией исходного кода Xterm. Запись termcap или terminfo должна поддерживать настройку вашего Xterm. В моем дистрибутиве Slackware Linux вы должны установить для переменной среды TERM одно из следующих значений:

* xterm
* xterm-цвет
* xterm-16цвет
* xterm-88цвет
* xterm-256цвет

Если запись termcap / terminfo отсутствует, вы можете добавить параметр «-assume_256color» в файл joerc. Обратите внимание, что это было нарушено для terminfo в версиях JOE ниже 3.4.

Когда он работает, команда: «joe -assume_256color -text_color bg_222» должна иметь серый фон.

## [Режим редактирования Hex][83]

Когда выбран этот режим (введите -hex в командную строку или найдите «Hex edit mode» после нажатия **^ T** ), буфер отображается как шестнадцатеричный дамп, но все команды редактирования работают одинаково. Наиболее полезно выбирать режим перепечатки вместе с шестнадцатеричным дампом (нажмите **^ TT** ). Тогда печатать не получится.

* Чтобы ввести шестнадцатеричный байт 0xF8, введите **^ Q x F 8**
* Вы можете использовать **^ KC,** чтобы скопировать блок как обычно. Если выбран режим замены, блок перезапишет целевые данные без изменения размера файла. В противном случае вставляет.
* Нажмите **Esc X byte <Enter>** , чтобы перейти к определенному смещению байта. В этом приглашении можно ввести шестнадцатеричные значения следующим образом: 0x2000.
* Поиск, инкрементный поиск и поиск и замена работают как обычно.

## [Переменные среды][84]

Для правильной работы JOE необходимо правильно указать ряд других настроек среды. Пропускная способность (скорость передачи) соединения между компьютером и вашим терминалом должна быть установлена ​​правильно, чтобы JOE плавно обновлял экран и позволял typeahead отложить обновление экрана. Используйте команду **stty nnn,** чтобы установить это. Вы хотите установить его как можно ближе к фактической пропускной способности соединения. Например, если вы подключены через модем со скоростью 1200 бод, вы хотите использовать это значение для **stty** . Если вы подключены через модем 14.4k, но терминальный сервер, к которому вы подключены, подключается к компьютеру со скоростью 9600 бод, вы хотите установить скорость 9600 бод. Специальная скорость передачи 38400 или **extb**используется, чтобы указать, что у вас очень высокоскоростное соединение, такое как консоль с отображением памяти или эмулятор терминала X-window. Если вы не можете использовать **stty** для установки фактической пропускной способности (возможно, из-за того, что модем обменивается данными с компьютером с другой скоростью, чем он обменивается данными по телефонной линии), вы можете вместо этого поместить числовое значение в переменную среды **BAUD** (используйте **setenv BAUD 9600** для csh или **BAUD = 9600; экспорт BAUD** для sh). 

В переменной среды **TERM** должен быть указан тип используемого вами терминала. Если размер (количество строк / столбцов) вашего терминала отличается от того, что указано в записи TERMCAP или TERMINFO, вы можете установить это с помощью команды **stty rows nn cols nn** или путем установки **переменных** среды **LINES** и **COLUMNS** . Размер терминала в современных системах варьируется и определяется ioctl, поэтому эти параметры часто не действуют.

JOE обычно ожидает, что управление потоком между компьютером и вашим терминалом будет использовать квитирование **^ S** / **^ Q** (то есть, если компьютер отправляет символы слишком быстро для вашего терминала, ваш терминал отправляет **^ S,** чтобы остановить вывод, и **^ Q,** чтобы перезапустить его. ). Если управление потоком использует внеполосное или аппаратное подтверждение связи или если ваш терминал достаточно быстр, чтобы всегда идти в ногу с выводом компьютера, и вы хотите сопоставить **^ S** / **^ Q** для редактирования команд, вы можете установить для переменной среды **NOXON** значение пусть JOE пытается выключить **^ S** / **^ Q**подтверждение связи. Если соединение между компьютером и вашим терминалом не использует квитирование и ваш терминал недостаточно быстр, чтобы не отставать от вывода компьютера, вы можете установить переменную среды **DOPADDING,** чтобы **JOE** замедлял вывод, вставляя символы PAD между терминалом последовательности обновления экрана.

Вот полный список переменных среды:

* BAUD   
Сообщите JOE скорость передачи терминала (отменяет значение, сообщаемое stty).
* COLORTERM   
Если установлено значение truecolorили 24bit, предполагается [поддержка 24-битного цвета][75] , и JOE сможет загружать эти разделы из цветовых схем.
* COLUMNS   
Задайте количество столбцов в эмуляторе терминала (в случае неправильного ввода termcap). Это полезно только в старых системах, у которых нет ioctl "получить размер окна".
* ДОБАВЛЕНИЕ   
Разрешить JOE отправлять заполнители NUL на терминал, если он установлен (для очень старых терминалов).
* HOME   
Используется для получения пути к домашнему каталогу для ~ расширения, а также для поиска каталога ~ / .joerc файла ~ / .joe.
* HOSTNAME   
Используется для получения имени хоста для установки совместимых с EMACS блокировок.
* JOETERM Указывает   
тип терминала: JOE будет использовать его вместо TERM, если он установлен.
* LANG   
Устанавливает языковой стандарт (например, en_US.utf-8). JOE использует первый из них, который установлен: LC_ALL, LC_CTYPE, LANG.
* LC_ALL   
Устанавливает языковой стандарт (например, en_US.utf-8). JOE использует первый из них, который установлен: LC_ALL, LC_CTYPE, LANG.
* LC_CTYPE   
Устанавливает языковой стандарт (например, en_US.utf-8). JOE использует первый из них, который установлен: LC_ALL, LC_CTYPE, LANG.
* LINES   
Установите количество строк в эмуляторе терминала (в случае неправильного ввода termcap). Это полезно только в старых системах, у которых нет ioctl "получить размер окна".
* NOXON   
Отключить управление потоком **^ S** и **^ Q** , возможно, позволяя использовать **^ S** и **^ Q** в качестве клавиш редактора.
* ОБОЛОЧКА   
Путь к оболочке (например, / bin / sh). Это используется в нескольких местах: Если вы находитесь в системе без управления заданиями, эта оболочка вызывается, когда вы нажимаете **^ KZ** . Также это оболочка, которая запускается в окнах оболочки. Если SHELL не установлен (Cygwin) или установлен в / bin / sh, JOE вызывает первый из существующих: / bin / bash, / usr / bin / bash, / bin / sh.
* SIMPLE_BACKUP_SUFFIX   
Если этот параметр установлен, он добавляется к имени файла вместо ~ для создания имени файла резервной копии.
* TAGS   
Если указан путь к файлу, JOE пытается использовать его как файл «тегов», если в текущем каталоге нет файла «тегов».
* TEMP   
Если установлено, дает путь к каталогу для открытия файла подкачки вместо / tmp
* TERMCAP   
Используется встроенным парсером файлов termcap JOE (не используется для terminfo). Запись termcap может быть помещена непосредственно в эту переменную (которая будет использоваться, если она соответствует TERM), или если она начинается с /, она дает список путей к файлам termcap для поиска.
* TERMPATH   
Предоставляет список путей к файлам termcap для поиска, когда в TERMCAP есть запись termcap (в противном случае она игнорируется). Список путей к файлам termcap по умолчанию (если их нет в TERMCAP и TERMPATH): "~ / .termcap / etc / joe / termcap / etc / termcap"
* TERM   
Указывает тип терминала, например "vt100" или "xterm".
* USER   
Используется для получения имени пользователя для файловых блокировок, совместимых с EMACS.

## [Команды JOE сгруппированы по функциям][85]

Эти команды можно вводить в командной строке **Esc X.**

### [Фоновые программы][86]

* bknd   
Запуск оболочки в окне
* vtbknd   
Запустить оболочку в окне эмулятора терминала
* killproc   
Убить программу в текущем окне
* запустить   
Выполнить команду UNIX в окне
* sys   
Запускает команду UNIX и по завершении возвращается в редактор (ввод-вывод не проходит через редактор, но мы получаем статус возврата команды).

### [Блоки][15]

* blkcpy   
Копировать отмеченный блок в курсор
* blkdel   
Удалить отмеченный блок
* blkmove   
Переместить отмеченный блок к курсору
* blksave   
Сохранить отмеченный блок в файл
* копировать   
Копировать блок в kill-ring
* drop   
Установить меткуb. Если он уже был установлен, устраните Айт.
* dropon   
Установить markb. Если он уже был установлен, удалите его. Включите режим маркировки.
* toggle_marking   
Если мы находимся в блоке: очистите markb и markk. Если маркировка выключена: установите markb и включите маркировку. Если маркировка включена: установите markk (при необходимости поменяйте местами с markb) и выключите маркировку.
* begin_marking   
Если мы находимся на краю блока: установите markb на другой край и включите режим маркировки. В противном случае установите markb на курсор и включите режим маркировки.
* выберите   
Установить отметкуb. Если он уже был установлен, ничего не делайте.
* filter   
Фильтровать блок или файл с помощью команды UNIX
* markb   
Установить начало метки блока
* markk   
Установить метку конца блока
* markl   
Отметить текущую строку
* nmark Удалить   
markb и markk
* picokill   
Удалить строку или блок
* pop   
Восстановить значения markb и markk из стека
* psh   
Помещать значения markb и markk в стек
* swap   
Переключить курсор на markb
* tomarkb   
Переместите курсор на markb
* tomarkbk   
Переместите курсор на markb или markk
* tomarkk   
Переместите курсор на markk
* yank   
Вставить верхнюю часть защитного кольца
* yankpop   
Прокрутите список убийств
* yapp   
Добавить следующее убийство в начало списка убийств
* верхний   
Преобразовать все в блоке в верхний регистр
* lower   
Преобразовать все в блоке в нижний регистр

### [Буферы][87]

* буферизованное   
меню буфера
* редактировать   
Загрузить файл в окно: запрашивает перезагрузку, если буфер существует
* переключатель   
Загрузить файл в окно: всегда использует буфер, если он существует
* царапина   
Вставить буфер царапины в текущее окно
* popabort Прервать   
и открыть окно из стека (ничего не делать, если стек пуст)
* nbuf   
Загрузить следующий буфер в текущее окно
* pbuf   
Загрузить предыдущий буфер в текущее окно
* reload   
Перечитать файл в буфер (вернуться)
* reloadall   
Перечитать все немодифицированные буферы

### [Курсор Движение][88]

* bof   
Переместить курсор в начало файла
* bol   
Переместить курсор в начало строки (всегда)
* bop   
Перейти к началу абзаца
* bos   
Перейти к началу экрана
* bkwdc   
Поиск символа в обратном направлении
* byte   
Переместите курсор к определенному байтовому смещению в файле.
* col   
Переместить курсор к определенному номеру столбца.
* dnarw   
Переместить курсор на одну строку вниз
* eof   
Переместить курсор в конец файла
* eol   
Переместить курсор в конец строки
* eop   
Переместить курсор в конец абзаца
* fwrdc   
Искать подходящий символ вперед
* gomark   
Переместить курсор на закладку
* home   
Переместить курсор в начало строки
* строка   
Переместить курсор на указанную строку
* ltarw   
Переместить курсор влево
* nedge   
Переместить курсор к следующему краю
* nextpos   
Переместить курсор в следующую позицию в истории позиций курсора
* NextWord   
Переместить курсор в конец следующего слова
* pedge   
Переместить курсор к предыдущему краю
* prevpos   
Переместить курсор в предыдущую позицию в истории позиций курсора
* prevword   
Переместить курсор в начало предыдущего слова
* rtarw   
Переместить курсор вправо
* setmark   
Установить закладку
* tomatch   
Переместить курсор к совпадающему разделителю
* tos   
Переместить курсор в верхнюю часть экрана
* uparw   
Переместить курсор вверх

### [Удаление][89]

* спины   
Backspace
* backw   
Backspace слово
* delbol   
Удалить до начала строки
* delch   
Удалить символ под курсором
* deleteol   
Удалить до конца строки
* dellin   
Удалить всю строку
* delw   
Удалить слово справа

### [Ошибка синтаксического анализа][90]

* nxterr   
Перейти к следующей проанализированной ошибке
* parserr   
Ошибки разбора в текущем файле
* gparse Разобрать   
список grep в текущем файле
* перейти   
Разобрать текущую строку и перейти к ней
* prverr   
Перейти к предыдущей разобранной ошибке
* душ   
Показать текущее сообщение
* grep   
Выполнить команду grep, проанализировать по завершении
* build   
Выполнить команду сборки, проанализировать по завершении
* релиз   
Release error / grep records

### [Выход][91]

* cancel   
Как abort, но не возвращает отказ: полезно в макросах для выхода из приглашения.
* abort   
Прервать текущий буфер / окно. Подскажите, если его поменяли.
* abortbuf То же, что   
и выше, но просто потерпит неудачу, если потребуется запрос, потому что это последнее окно в измененном буфере.
* спросить   
Запрос на сохранение текущего файла: пользователь говорит да вернуться, пользователь говорит нет: запустить 'abort'. Используйте в макросе: "спросить, запросить, сохранить"
* exsave   
Сохранить файл и выйти
* потерять   
буфер уничтожения EMACS. Буфер удаляется - все окна с ним получают замену временного буфера.
* querysave   
Запрос на сохранение каждого измененного буфера. Используйте в макросе: "querysave, query, killjoe"
* killjoe Немедленно   
выйти из JOE, не проверяя наличие измененных буферов

### [Файлы][92]

* cd   
Установить префикс каталога
* сохранить   
Сохранить файл
* savenow   
Сохранить немедленно, если имя файла не известно
* insf   
Вставить файл

### [Форматирование][93]

* центральная   
центральная линия
* fmtblk   
Форматировать все абзацы в блоке
* формат   
Форматировать текущий абзац
* липа   
Отступ слева
* rindent   
Отступ справа

### [Помогите][94]

* help   
Включить или отключить помощь
* hnext   
Перейти к следующему экрану справки
* hprev   
Перейти к предыдущему экрану справки

### [Вставка][95]

* ctrl   
Введите следующий ключ
* закончить   
Полное слово в текстовом окне
* insc   
Вставить пробел
* открыть   
Вставить новую строку
* цитата   
Вставить управляющий символ
* quote8   
Вставить метасимвол
* rtn Клавиша   
**возврата** / **ввода**
* тип   
Вставить набранный символ
* secure_type   
Вставить набранный символ, но разрешено только в окнах подсказок (не разрешено в окнах оболочки)

### [Макросы][96]

* макросы   
Вставить макросы клавиатуры в текущий файл
* играть   
Выполнить макрос
* query   
Приостановить запись макроса для пользовательского запроса
* запись   
Записать макрос
* стоп   
Остановить запись макроса

### [Меню][97]

* backsmenu   
Отменить в меню завершения файла
* bofmenu   
Перейти в начало меню
* bolmenu   
Перейти к началу строки в меню
* dnarwmenu   
Перейти на одну строку вниз в меню
* eolmenu   
Переместить курсор в конец строки в меню
* eofmenu   
Переместите курсор в конец меню
* ltarwmenu   
Перемещение курсора влево в меню
* rtarwmenu   
Переместить курсор вправо в меню
* uparwmenu   
Перемещение курсора вверх в меню
* dnslidemenu   
Прокрутить меню на одну строку вниз
* upslidemenu   
Прокрутка меню на одну строку вверх
* pgupmenu   
Прокрутить меню вверх
* pgdnmenu   
Прокрутить меню вниз
* tabmenu   
Вкладка через меню

### [Разное][98]

* гудок   
гудок
* execmd   
Выполнить команду JOE
* debug_joe   
Вставить отладочную информацию в буфер
* математический   
калькулятор
* maths   
Secure Calculator (нет возможности запускать макросы joe ())
* режим   
Подсказка режима
* меню   
Подсказка меню
* msg   
Показать сообщение
* notmod   
Сбросить измененный флаг
* повторно ввести   
Обновить экран
* оболочка   
Приостановить процесс или выполнить вспомогательную оболочку
* stat   
Отображение позиции курсора
* тег   
Теги поиск файла
* tagjump   
Перейти к следующему совпадению поиска файла тегов (только если установлено notagsmenu)
* таймер   
Периодически выполнять макрос
* txt   
Вставить текст. Если первый символ - `, то предполагается, что текст является строкой формата (то есть строкой, используемой для определения строки состояния для параметров rmsg и lmsg) и форматируется перед вставкой.
* имя   
Вставить текущее имя файла
* язык   
Вставить текущий язык
* charset   
Вставить текущий набор символов
* keymap   
Переключиться на другую раскладку

### [Подсказки][23]

* complete   
Введите имя файла в подсказке
* if   
Выполнять только следующие команды, если expr истинно (ненулевое)
* затем   
То же, что и rtn, но работает только в окнах подсказок
* elsif   
Попробуйте новое условие
* else   
Переключить флаг правды
* endif   
Снова запустить cmds

Вот пример макроса if:

если "char == 65", то "это A", иначе "это не A", endif **^ [q**

Когда вы нажимаете **^ [q** , если символ под курсором - «A»: «это A» вставляется в буфер, в противном случае вставляется «это не A».

«если» создает математическую подсказку (например, **Esc M** ). «then» похоже на «rtn» - оно нажимает клавишу возврата для этого приглашения.

В математической подсказке доступны следующие переменные:

* char   
значение ASCII символа под курсором
* ширина   
Ширина экрана
* высота   
Высота экрана
* байт   
номер байта
* Col   
номер столбца
* линия   
номер строки
* строк   
нет. строки в файле
* верхняя   
строка номер верхней строки окна

### [Повторение][47]

* arg   
Запрашивать повторный аргумент
* uarg   
Универсальный аргумент

### [Прокрутка][99]

* ползать   
Панорамирование влево
* crawlr   
Панорамирование экрана вправо
* dnslide   
Прокрутка экрана вниз на 1 строку
* pgdn   
Прокрутка экрана вниз
* pgup   
Прокрутка экрана вверх
* upslide   
Прокрутка вверх на одну строку

### [Искать и заменить][100]

* ffirst   
Найти текст
* fnext   
Повторить предыдущий поиск
* isrch   
Инкрементальный поиск вперед
* qrepl   
Найти и заменить
* rfirst   
Поиск текста в обратном направлении
* rsrch   
Обратный инкрементный поиск

### [Windows][41]

* explode   
Показать одно окно или отобразить все окна
* dupw   
Дублировать текущее окно
* Groww   
Увеличить размер окна
* nextw   
Переместить курсор в следующее окно
* prevw   
Перейти к предыдущему окну
* shrinkw   
Окно сжатия
* splitw   
Разделить окно на два
* tw0 Удалить   
это окно
* tw1   
Показать только одно окно
* mwind Вывести   
на экран окно сообщений об ошибках и поместить в него курсор.
* showlog   
Получить временный буфер журнала запуска в окно.
* mfit Уместить   
два окна на экране: сделать текущее окно 6 строками, а остальное место оставить окну выше. Окно выше - это либо существующее предыдущее окно, либо новое созданное, если его еще не было.

### [Отменить][101]

* redo   
Повторно выполнить последнее отмененное изменение
* отменить   
Отменить последнее изменение

### [Мышь][102]

* мышь   
Переместите курсор туда, где была нажата / перетащена мышь
* defmdown Обработчик   
однократного щелчка по умолчанию, обычно привязанный к MDOWN. Помещает курсор мыши и начинает область.
* defmup   
Стандартный обработчик выпуска одним щелчком, обычно привязанный к MUP. Завершает выбор региона.
* defmdrag   
Обработчик перетаскивания одним щелчком по умолчанию, обычно привязанный к MDRAG. Выделяет область текста по символу за раз.
* defm2down Обработчик   
двойного щелчка по умолчанию, обычно привязанный к M2DOWN.
* defm2up   
Стандартный обработчик выпуска двойным щелчком, обычно привязанный к M2UP.
* defm2drag   
Обработчик перетаскивания двойным щелчком по умолчанию, обычно привязанный к M2DRAG. Выбирает область текста по слову за раз.
* defm3down Обработчик   
тройного щелчка по умолчанию, обычно привязанный к M3DOWN.
* defm3up   
Стандартный обработчик релиза с тройным щелчком, обычно привязанный к M3UP.
* defm3drag   
Обработчик перетаскивания с тройным щелчком по умолчанию, обычно привязанный к M3DRAG. Выделяет область текста построчно.
* defmiddledown Обработчик   
среднего щелчка по умолчанию, обычно привязанный к MIDDLEDOWN. Это вставляет текст.
* defmiddleup Обработчик отпускания   
средней кнопки по умолчанию, обычно привязанный к MIDDLEUP.
* xtmouse   
Обрабатывает события мыши xterm, обычно привязанные к Esc [M. Он анализирует остальную часть последовательности и генерирует поддельные «ключи», которые могут быть привязаны к макросам в файле joerc. Он использует таймер для обнаружения двойного и тройного щелчка. Ключи: MUP, MDOWN, MDRAG, M2UP, M2DOWN, M2DRAG, M3UP, M3DOWN, M3DRAG, MWUP и MWDOWN.
* extmouse   
Обрабатывает расширенные события мыши xterm, обычно привязанные к Esc [\ <.
* paste   
Вставить текст в кодировке base64 (для параметра XTerm --enable-base64).
* brpaste   
Отключить автоотступ, перенос слов и пробелы. Идея состоит в том, чтобы связать это с **Esc [2 0 0 ~,** чтобы, когда эмулятор терминала отправляет вставку мыши, текст вставляется как есть.
* brpaste_done   
Восстанавливает режимы автоотступа, переноса слов и пробелов до их исходных значений перед brpaste. Идея состоит в том, чтобы связать это с **Esc [2 0 1 ~,** чтобы эти режимы восстанавливались после вставки мыши.

links: https://joe-editor.sourceforge.io/4.5/man.html

[0]: #joe-joe-s-own-editor
[1]: #syntax
[2]: #description
[3]: http://www.sourceforge.net/projects/joe-editor
[4]: #usage
[5]: #filenames
[6]: #joerc
[7]: #evariables
[8]: #command-line-options
[9]: #colors-and-attributes
[10]: #status-line-definition-strings
[11]: #basic-editing
[12]: #cursor-position-history
[13]: #save-and-exit
[14]: #file-operations
[15]: #blocks
[16]: #using-joe-in-a-shell-script
[17]: #word-wrap-and-formatting
[18]: #centering
[19]: #spell-checker
[20]: #overtype-mode
[21]: #control-and-meta-characters
[22]: #character-sets-and-utf-8
[23]: #prompts
[24]: #completion-and-selection-menus
[25]: #where-am-i-
[26]: #what-if-i-hit-__-k__-by-accident-
[27]: #temporarily-suspending-the-editor
[28]: #searching-for-text
[29]: #regular-expressions
[30]: #escape-sequences
[31]: ftp://ftp.unicode.org/Public/8.0.0/ucd/Blocks.txt
[32]: ftp://ftp.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values
[33]: #incremental-search
[34]: #goto-matching-delimiter
[35]: #regions
[36]: #how-do-i-deselect-a-highlighted-region-
[37]: #new-ways-of-selecting-regions
[38]: #indenting-program-blocks
[39]: #rectangle-mode
[40]: #picture-mode
[41]: #windows
[42]: #windowing-system-model
[43]: #scratch-buffers
[44]: #keyboard-macros
[45]: #keyboard-macro-subroutines
[46]: #query-suspend
[47]: #repeat
[48]: #macros-and-commands
[49]: #define-your-own
[50]: #command-prompt
[51]: #list
[52]: #macro-don-t-stop-modifier
[53]: #macro-repeat-argument-modifiers
[54]: #-psh-query-interaction
[55]: #tags-search
[56]: #calculator
[57]: #math-functions
[58]: #variables
[59]: #commands
[60]: #operators-
[61]: #shell-windows
[62]: #pop-up-shell-windows
[63]: #use-cases
[64]: #how-it-works-
[65]: #compiler-and-grep-find-parsers
[66]: #grep-find
[67]: #compile
[68]: #syntax-highlighting
[69]: #how-joe-syntax-highlighting-works
[70]: http://joe-editor.hg.sourceforge.net/hgweb/joe-editor/joe-editor/file/tip/syntax/c.jsf.in
[71]: #escapes
[72]: #subroutines
[73]: #color-schemes
[74]: #color-scheme-files
[75]: https://gist.github.com/XVilka/8346728
[76]: #the-joerc-file
[77]: #initialization-file-loading-sequence
[78]: #joerc-file-sections
[79]: #mode-command
[80]: #menu-command
[81]: #xterm-mouse-support
[82]: #color-xterm-support
[83]: #hex-edit-mode
[84]: #environment-variables
[85]: #joe-commands-grouped-by-function
[86]: #background-programs
[87]: #buffers
[88]: #cursor-motion
[89]: #deletion
[90]: #error-parsing
[91]: #exit
[92]: #files
[93]: #formatting
[94]: #help
[95]: #inserting
[96]: #macros
[97]: #menu
[98]: #misc
[99]: #scrolling
[100]: #search-and-replace
[101]: #undo
[102]: #mouse
